D0013668WEKA使用教程(经典教程转载)教程目录1. 简介2. 数据式3.数据准备4. 关联规则（购物篮分析）5. 分类与回归6. 聚类分析1. 简介weka的全名是怀卡托智能分析环境（waikato environment for knowledge analysis），它的源代码可通过得到。同时weka也是新西兰的一种鸟名，而weka的主要开发者来自新西兰。weka作为一个公开的数据挖掘工作平台，集合了大量能承担数据挖掘任务的机器学习算法，包括对数据进行预处理，分类，回归、聚类、关联规则以及在新的交互式界面上的可视化。如果想自己实现数据挖掘算法的话，可以看一看weka的接口文档。在weka中集成自己的算法甚至借鉴它的方法自己实现可视化工具并不是件很困难的事情。2005年8月，在第11届acm sigkdd国际会议上，怀卡托大学的weka小组荣获了数据挖掘和知识探索领域的最高服务奖，weka系统得到了广泛的认可，被誉为数据挖掘和机器学习历史上的里程碑，是现今最完备的数据挖掘工具之一（已有11年的发展历史）。weka的每月下载次数已超过万次。--整理自2. 数据式巧妇难为无米之炊。首先我们来看看weka所用的数据应是什么样的式。跟很多电子表或数据分析软件一样，weka所处理的数据集是图1那样的一个二维的表。图1这里我们要介绍一下weka中的术语。表里的一个横行称作一个实例（instance），相当于统计学中的一个样本，或者数据库中的一条记录。竖行称作一个属性（attrbute），相当于统计学中的一个变量，或者数据库中的一个字段。这样一个表，或者叫数据集，在weka看来，呈现了属性之间的一种关系(relation)。图1中一共有14个实例，5个属性，关系名称为“weather”。weka存储数据的式是arff（attribute-relation file format）文件，这是一种ascii文本文件。图1所示的二维表存储在如下的arff文件中。这也就是weka自带的“weather.arff”文件，在weka安装目录的“data”子目录下可以找到。需要注意的是，在windows记事本打开这个文件时，可能会因为回车符定义不一致而导致分行不正常。推荐使用这样的字符编辑软件察看arff文件的内容。下面我们来对这个文件的内容进行说明。识别arff文件的重要依据是分行，因此不能在这种文件里随意的断行。空行（或全是空的行）将被忽略。以“%”开始的行是注释，weka将忽略这些行。如果你看到的“weather.arff”文件多了或少了些“%”开始的行，是没有影响的。除去注释后，整个arff文件可以分为两个部分。第一部分给出了头信息（head information），包括了对关系的声明和对属性的声明。第二部分给出了数据信息（data information），即数据集中给出的数据。从“@data”标记开始，后面的就是数据信息了。关系声明关系名称在arff文件的第一个有效行来定义，式为@relation relation-namerelation-name是一个字符串。如果这个字符串包含空，它必须加上引号（指英文标点的单引号或双引号）。属性声明属性声明用一列以“@attribute”开头的语句表示。数据集中的每一个属性都有它对应的“@attribute”语句，来定义它的属性名称和数据类型。这些声明语句的顺序很重要。首先它表明了该项属性在数据部分的位置。例如，“humidity”是第三个被声明的属性，这说明数据部分那些被逗号分开的列中，第三列数据 85 90 86 96 ... 是相应的“humidity”。其次，最后一个声明的属性被称作class属性，在分类或回归任务中，它是默认的目标变量。属性声明的式为@attribute attribute-name datatype其中attribute-name是必须以字母开头的字符串。和关系名称一样，如果这个字符串包含空，它必须加上引号。weka支持的datatype有四种，分别是numeric-------------------------数型nominal-specification-----分类（nominal）型string----------------------------字符串型date [date-format]--------日期和时间型其中nominal-specification 和date-format 将在下面说明。还可以使用两个类型“integer”和“real”，但是weka把它们都当作“numeric”看待。注意“integer”，“real”，“numeric”，“date”，“string”这些关键字是区分大小写的，而“relation”“attribute ”和“date”则不区分。数属性数型属性可以是整数或者实数，但weka把它们都当作实数看待。分类属性分类属性由nominal-specification列出一系列可能的类别名称并放在花括号中：{nominal-name1, nominal-name2, nominal-name3, ...} 。数据集中该属性的只能是其中一种类别。例如如下的属性声明说明“outlook”属性有三种类别：“sunny”，“ overcast”和“rainy”。而数据集中每个实例对应的“outlook”必是这三者之一。@attribute outlook {sunny, overcast, rainy}如果类别名称带有空，仍需要将之放入引号中。字符串属性字符串属性中可以包含任意的文本。这种类型的属性在文本挖掘中非常有用。示例：@attribute lcc string日期和时间属性日期和时间属性统一用“date”类型表示，它的式是@attribute name date [date-format]其中name是这个属性的名称，date-format是一个字符串，来规定该怎样解析和显示日期或时间的式，默认的字符串是iso-8601所给的日期时间组合式“yyyy-mm-ddthh:mm:ss”。数据信息部分表达日期的字符串必须符合声明中规定的式要求（下文有例子）。数据信息数据信息中“@data”标记独占一行，剩下的是各个实例的数据。每个实例占一行。实例的各属性用逗号“,”隔开。如果某个属性的是缺失（missing value），用问号“?”表示，且这个问号不能省略。例如：@datasunny,85,85,false,no?,78,90,?,yes字符串属性和分类属性的是区分大小写的。若中含有空，必须被引号括起来。例如：@relation lccvslcsh@attribute lcc string@attribute lcsh string@dataag5, 'encyclopedias and dictionaries.;twentieth century.'as262, 'science -- soviet union -- history.'日期属性的必须与属性声明中给定的相一致。例如：@relation timestamps@attribute timestamp date yyyy-mm-dd hh:mm:ss@data2001-04-03 12:12:122001-05-03 12:59:55稀疏数据有的时候数据集中含有大量的0（比如购物篮分析），这个时候用稀疏式的数据存贮更加省空间。稀疏式是针对数据信息中某个实例的表示而言，不需要修改arff文件的其它部分。看如下的数据：@data0, x, 0, y, class a0, 0, w, 0, class b用稀疏式表达的话就是@data{1 x, 3 y, 4 class a}{2 w, 4 class b}每个实例用花括号括起来。实例中每一个非0的属性用index 空 value表示。index是属性的序号，从0开始计；value是属性。属性之间仍用逗号隔开。这里每个实例的数必须按属性的顺序来写，如{1 x, 3 y, 4 class a}，不能写成{3 y, 1 x, 4 class a}。注意在稀疏式中没有注明的属性不是缺失，而是0。若要表示缺失必须显式的用问号表示出来。relational型属性在weka 3.5版中增加了一种属性类型叫做relational，有了这种类型我们可以像关系型数据库那样处理多个维度了。但是这种类型目前还不见广泛应用，暂不作介绍。--整理自和3.数据准备使用weka作数据挖掘，面临的第一个问题往往是我们的数据不是arff式的。幸好，weka还提供了对csv文件的支持，而这种式是被很多其他软件所支持的。此外，weka还提供了通过jdbc访问数据库的功能。在这一节里，我们先以excel和matlab为例，说明如何获得csv文件。然后我们将知道csv文件如何转化成arff文件，毕竟后者才是weka支持得最好的文件式。面对一个arff文件，我们仍有一些预处理要做，才能进行挖掘任务。.* - .csv我们给出一个csv文件的例子（）。用ultraedit打开它可以看到，这种式也是一种逗号分割数据的文本文件,储存了一个二维表。excel的xls文件可以让多个二维表放到不同的工作表（sheet）中，我们只能把每个工作表存成不同的csv文件。打开一个xls文件并切换到需要转换的工作表，另存为csv类型，点“确定”、“是”忽略提示即可完成操作。在matlab中的二维表是一个矩阵，我们通过这条命令把一个矩阵存成csv式。csvwrite('filename',matrixname)需要注意的是，matllab给出的csv文件往往没有属性名（excel给出的也有可能没有）。而weka必须从csv文件的第一行读取属性名，否则就会把第一行的各属性读成变量名。因此我们对于matllab给出的csv文件需要用ultraedit打开，手工添加一行属性名。注意属性名的个数要跟数据属性的个数一致，仍用逗号隔开。.csv - .arff将csv转换为arff最迅捷的办法是使用weka所带的命令行工具。运行weka的主程序，出现gui后可以点击下方按钮进入相应的模块。我们点击进入“simple cli”模块提供的命令行功能。在新窗口的最下方（上方是不能写字的）输入框写上java weka.core.converters.csvloader filename.csv  filename.arff即可完成转换。在weka 3.5中提供了一个“arff viewer”模块，我们可以用它打开一个csv文件将进行浏览，然后另存为arff文件。进入“exploer”模块，从上方的按钮中打开csv文件然后另存为arff文件亦可。“exploer”界面我们应该注意到，“exploer”还提供了很多功能，实际上可以说这是weka使用最多的模块。现在我们先来熟悉它的界面，然后利用它对数据进行预处理。图2图2显示的是使用3.5版exploer打开bank-data.csv的情况。我们根据不同的功能把这个界面分成8个区域。区域1的几个选项卡是用来切换不同的挖掘任务面板。这一节用到的只有“preprocess”，其他面板的功能将在以后介绍。区域2是一些常用按钮。包括打开数据，保存及编辑功能。我们在这里把bank-data.csv另存为bank-data.arff。在区域3中“choose”某个“filter”，可以实现筛选数据或者对数据进行某种变换。数据预处理主要就利用它来实现。区域4展示了数据集的一些基本情况。区域5中列出了数据集的所有属性。勾选一些属性并“remove”就可以删除它们，删除后还可以利用区域2的“undo”按钮找回。区域5上方的一排按钮是用来实现快速勾选的。在区域5中选中某个属性，则区域6中有关于这个属性的摘要。注意对于数属性和分类属性，摘要的方式是不一样的。图中显示的是对数属性“income”的摘要。区域7是区域5中选中属性的直方图。若数据集的最后一个属性（我们说过这是分类或回归任务的默认目标变量）是分类变量（这里的“pep”正好是），直方图中的每个长方形就会按照该变量的比例分成不同颜色的段。要想换个分段的依据，在区域7上方的下拉框中选个不同的分类属性就可以了。下拉框里选上“no class”或者一个数属性会变成黑白的直方图。区域8是状态栏，可以查看log以判断是否有错。右边的weka鸟在动的话说明weka正在执行挖掘任务。右键点击状态栏还可以执行java内存的垃圾回收。预处理bank-data数据各属性的含义如下：ida unique identification numberageage of customer in years (numeric)sexmale / femaleregioninner_city/rural/suburban/townincomeincome of customer (numeric)marriedis the customer married (yes/no)childrennumber of children (numeric)cardoes the customer own a car (yes/no)save_acctdoes the customer have a saving account (yes/no)current_acctdoes the customer have a current account (yes/no)mortgagedoes the customer have a mortgage (yes/no)pepdid the customer buy a pep (personal equity plan) after the last mailing (yes/no)通常对于数据挖掘任务来说，id这样的信息是无用的，我们将之删除。在区域5勾选属性“id”，并点击“remove”。将新的数据集保存一次，并用ultraedit打开这个arff文件。我们发现，在属性声明部分，weka已经为每个属性选好了合适的类型。我们知道，有些算法，只能处理所有的属性都是分类型的情况。这时候我们就需要对数型的属性进行离散化。在这个数据集中有3个变量是数型的，分别是“age”，“income”和“children”。其中“children”只有4个取：0，1，2，3。这时我们在ultraedit中直接修改arff文件，把@attribute children numeric改为@attribute children {0,1,2,3}就可以了。在“explorer”中重新打开“bank-data.arff”，看看选中“children”属性后，区域6那里显示的“type”是不是变成“nominal”了？“age”和“income”的离散化我们需要借助weka中名为“discretize”的filter来完成。在区域2中点“choose”，出现一棵“filter树”，逐级找到“weka.filters.unsupervised.attribute.discretize”，点击。若无法关闭这个树，在树之外的地方点击“explorer”面板即可。现在“choose”旁边的文本框应该显示“discretize -b 10 -m -0.1 -r first-last”。 点击这个文本框会弹出新窗口以修改离散化的参数。我们不打算对所有的属性离散化，只是针对对第1个和第4个属性（见区域5属性名左边的数字），故把attributeindices右边改成“1,4”。计划把这两个属性都分成3段，于是把“bins”改成“3”。其它框里不用更改，关于它们的意思可以点“more”查看。点“ok”回到“explorer”，可以看到“age”和“income”已经被离散化成分类型的属性。若想放弃离散化可以点区域2的“undo”。如果对“(-inf-34.333333]”这样晦涩的标识不满，我们可以用ultraedit打开保存后的arff文件，把所有的“'\'(-inf-34.333333]\''”替换成“0_34”。其它标识做类地手动替换。经过上述操作得到的数据集我们保存为。----整理自4. 关联规则（购物篮分析）注意：目前，weka的关联规则分析功能仅能用来作示范，不适合用来挖掘大型数据集。我们打算对前面的“bank-data”数据作关联规则的分析。用“explorer”打开“bank-data-final.arff”后，切换到“associate”选项卡。默认关联规则分析是用apriori算法，我们就用这个算法，但是点“choose”右边的文本框修改默认的参数，弹出的窗口中点“more”可以看到各参数的说明。背景知识首先我们来温习一下apriori的有关知识。对于一条关联规则l-r，我们常用支持度（support）和置信度（confidence）来衡量它的重要性。规则的支持度是用来估计在一个购物篮中同时观察到l和r的概率p(l,r)，而规则的置信度是估计购物栏中出现了l时也出会现r的条件概率p(r|l)。关联规则的目标一般是产生支持度和置信度都较高的规则。有几个类的度量代替置信度来衡量规则的关联程度，它们分别是lift（提升度？）：p(l,r)/(p(l)p(r))lift=1时表示l和r独立。这个数越大，越表明l和r存在在一个购物篮中不是偶然现象。leverage（不知道怎么翻译）：p(l,r)-p(l)p(r)它和lift的含义差不多。leverage=0时l和r独立，leverage越大l和r的关系越密切。conviction（更不知道译了）：p(l)p(!r)/p(l,!r)（!r表示r没有发生）conviction也是用来衡量l和r的独立性。从它和lift的关系（对r取反，代入lift公式后求倒数）可以看出，我们也希望这个越大越好。得注意的是，用lift和leverage作标准时，l和r是对称的，confidence和conviction则不然。参数设置现在我们计划挖掘出支持度在10%到100%之间，并且lift超过1.5且lift排在前100位的那些关联规则。我们把“lowerboundminsupport”和“upperboundminsupport”分别设为0.1和1，“metrictype”设为lift，“minmetric”设为1.5，“numrules”设为100。其他选项保持默认即可。“ok” 之后在“explorer”中点击“start”开始运行算法，在右边窗口显示数据集摘要和挖掘结果。下面是挖掘出来的lift排前5的规则。best rules found:1. age=52_max save_act=yes current_act=yes 113 == income=43759_max 61 conf:(0.54)  lift:(4.05) lev:(0.0[45] conv:(1.85)2. income=43759_max 80 == age=52_max save_act=yes current_act=yes 61 conf:(0.76)  lift:(4.05) lev:(0.0 [45] conv:(3.25)3. income=43759_max current_act=yes 63 == age=52_max save_act=yes 61 conf:(0.97)  lift:(3.85) lev:(0.0 [45] conv:(15.72)4. age=52_max save_act=yes 151 == income=43759_max current_act=yes 61 conf:(0.4)  lift:(3.85) lev:(0.0 [45] conv:(1.49)5. age=52_max save_act=yes 151 == income=43759_max 76 conf:(0.5)  lift:(3.77) lev:(0.09) [55] conv:(1.72)对于挖掘出的每条规则，weka列出了它们关联程度的四项指标。命令行方式我们也可以利用命令行来完成挖掘任务，在“simlpe cli”模块中输入如下式的命令：java weka.associations.apriori options -t directory-path\bank-data-final.arff即可完成apriori算法。注意，“-t”参数后的文件路径中不能含有空。在前面我们使用的option为-n 100 -t 1 -c 1.5 -d 0.05 -u 1.0 -m 0.1 -s -1.0命令行中使用这些参数得到的结果和前面利用gui得到的一样。我们还可以加上“- i”参数，得到不同项数的频繁项集。我用的命令如下：java weka.associations.apriori -n 100 -t 1 -c 1.5 -d 0.05 -u 1.0 -m 0.1 -s -1.0 -i -t d:\weka\bank-data-final.arff挖掘结果在上方显示，应是的样子。----整理自5. 分类与回归背景知识weka把分类(classification)和回归(regression)都放在“classify”选项卡中，这是有原因的。在这两个任务中，都有一个目标属性（输出变量）。我们希望根据一个样本(weka中称作实例)的一组特征（输入变量），对目标进行预测。为了实现这一目的，我们需要有一个训练数据集，这个数据集中每个实例的输入和输出都是已知的。观察训练集中的实例，可以建立起预测的模型。有了这个模型，我们就可以新的输出未知的实例进行预测了。衡量模型的好坏就在于预测的准确程度。在weka中，待预测的目标（输出）被称作class属性，这应该是来自分类任务的“类”。一般的，若class属性是分类型时我们的任务才叫分类，class属性是数型时我们的任务叫回归。选择算法这一节中，我们使用c4.5决策树算法对bank-data建立起分类模型。我们来看原来的“”文件。“id”属性肯定是不需要的。由于c4.5算法可以处理数型的属性，我们不用像前面用关联规则那样把每个变量都离散化成分类型。尽管如此，我们还是把“children”属性转换成分类型的两个“yes”和“no”。另外，我们的训练集仅取原来数据集实例的一半；而从另外一半中抽出若干条作为待预测的实例，它们的“pep”属性都设为缺失。经过了这些处理的训练集数据在下载；待预测集数据在下载。我们用“explorer”打开训练集“bank.arff”，观察一下它是不是按照前面的要求处理好了。切换到“classify”选项卡，点击“choose”按钮后可以看到很多分类或者回归的算法分门别类的列在一个树型框里。3.5版的weka中，树型框下方有一个“filter...”按钮，点击可以根据数据集的特性过滤掉不合适的算法。我们数据集的输入属性中有“binary”型（即只有两个类的分类型）和数型的属性，而class变量是“binary”的；于是我们勾选“binary attributes”“numeric attributes”和“binary class”。点“ok”后回到树形图，可以发现一些算法名称变红了，说明它们不能用。选择“trees”下的“j48”，这就是我们需要的c4.5算法，还好它没有变红。点击“choose”右边的文本框，弹出新窗口为该算法设置各种参数。点“more”查看参数说明，点“capabilities”是查看算法适用范围。这里我们把参数保持默认。现在来看左中的“test option”。我们没有专门设置检验数据集，为了保证生成的模型的准确性而不至于出现过拟合（overfitting）的现象，我们有必要采用10折交叉验证（10-fold cross validation）来选择和评估模型。若不明白交叉验证的含义可以一下。建模结果ok，选上“cross-validation”并在“folds”框填上“10”。点“start”按钮开始让算法生成决策树模型。很快，用文本表示的一棵决策树，以及对这个决策树的误差分析等等结果出现在右边的“classifier output”中。同时左下的“results list”出现了一个项目显示刚才的时间和算法名称。如果换一个模型或者换个参数，重新“start”一次，则“results list”又会多出一项。我们看到“j48”算法交叉验证的结果之一为correctly classified instances 206 68.6667 %也就是说这个模型的准确度只有69%左右。也许我们需要对原属性进行处理，或者修改算法的参数来提高准确度。但这里我们不管它，继续用这个模型。右键点击“results list”刚才出现的那一项，弹出菜单中选择“visualize tree”，新窗口里可以看到图形模式的决策树。建议把这个新窗口最大化，然后点右键，选“fit to screen”，可以把这个树看清楚些。看完后截图或者关掉这里我们解释一下“confusion matrix”的含义。=== confusion matrix ===a b -- classified as74 64 | a = yes30 132 | b = no这个矩阵是说，原本“pep”是“yes”的实例，有74个被正确的预测为“yes”，有64个错误的预测成了“no”；原本“pep”是“no”的实例，有30个被错误的预测为“yes”，有132个正确的预测成了“no”。746430132 = 300是实例总数，而(74132)/300 = 0.68667正好是正确分类的实例所占比例。这个矩阵对角线上的数字越大，说明预测得越好。模型应用现在我们要用生成的模型对那些待预测的数据集进行预测了。注意待预测数据集和训练用数据集各个属性的设置必须是一致的。即使你没有待预测数据集的class属性的，你也要添加这个属性，可以将该属性在各实例上的均设成缺失。在“test opion”中选择“supplied test set”，并且“set”成你要应用模型的数据集，这里是“bank-new.arff”文件。现在，右键点击“result list”中刚产生的那一项，选择“re-evaluate model on current test set”。右边显示结果的区域中会增加一些内容，告诉你该模型应用在这个数据集上表现将如何。如果你的class属性都是些缺失，那这些内容是无意义的，我们关注的是模型在新数据集上的预测。现在点击右键菜单中的“visualize classifier errors”，将弹出一个新窗口显示一些有关预测误差的散点图。点击这个新窗口中的“save”按钮，保存一个arff文件。打开这个文件可以看到在倒数第二个位置多了一个属性（predictedpep），这个属性上的就是模型对每个实例的预测。使用命令行（推荐）虽然使用图形界面查看结果和设置参数很方便，但是最直接最灵活的建模及应用的办法仍是使用命令行。打开“simple cli”模块，像上面那样使用“j48”算法的命令式为：java weka.classifiers.trees.j48 -c 0.25 -m 2 -t directory-path\bank.arff -d directory-path \bank.model其中参数“ -c 0.25”和“-m 2”是和图形界面中所设的一样的。“-t ”后面跟着的是训练数据集的完整路径（包括目录和文件名），“-d ”后面跟着的是保存模型的完整路径。注意！这里我们可以把模型保存下来。输入上述命令后，所得到树模型和误差分析会在“simple cli”上方显示，可以复制下来保存在文本文件里。误差是把模型应用到训练集上给出的。把这个模型应用到“bank-new.arff”所用命令的式为：其中“-p 9”说的是模型中的待预测属性的真实存在第9个（也就是“pep”）属性中，这里它们全部未知因此全部用缺失代替。“-l”后面是模型的完整路径。“-t”后面是待预测数据集的完整路径。输入上述命令后，在“simple cli”上方会有这样一些结果：0 yes 0.75 ?1 no 0.7272727272727273 ?2 yes 0.95 ?3 yes 0.8813559322033898 ?4 no 0.8421052631578947 ?...这里的第一列就是我们提到过的“instance_number”，第二列就是刚才的“predictedpep”，第四列则是“bank-new.arff”中原来的“pep”（这里都是“?”缺失）。第三列对预测结果的置信度（confidence ）。比如说对于实例0，我们有75%的把握说它的“pep”的会是“yes”，对实例4我们有84.2%的把握说它的“pep”会是“no”。我们看到，使用命令行至少有两个好处。一个是可以把模型保存下来，这样有新的待预测数据出现时，不用每次重新建模，直接应用保存好的模型即可。另一个是对预测结果给出了置信度，我们可以有选择的采纳预测结果，例如，只考虑那些置信度在85%以上的结果。----整理自6. 聚类分析原理与实现聚类分析中的“类”（cluster）和前面分类的“类”（class）是不同的，对cluster更加准确的翻译应该是“簇”。聚类的任务是把所有的实例分配到若干的簇，使得同一个簇的实例聚集在一个簇中心的周围，它们之间距离的比较近；而不同簇实例之间的距离比较远。对于由数型属性刻画的实例来说，这个距离通常指欧氏距离。现在我们对前面的“bank data”作聚类分析，使用最常见的k均（k-means）算法。下面我们简单描述一下k均聚类的步骤。k均算法首先随机的指定k个簇中心。然后：1)将每个实例分配到距它最近的簇中心，得到k个簇；2)计分别计算各簇中所有实例的均，把它们作为各簇新的簇中心。重复1)和2)，直到k个簇中心的位置都固定，簇的分配也固定。上述k均算法只能处理数型的属性，遇到分类型的属性时要把它变为若干个取0和1的属性。weka将自动实施这个分类型到数型的变换，而且weka会自动对数型的数据作标准化。因此，对于原始数据“bank-data.csv”，我们所做的预处理只是删去属性“id”，保存为arff式后，修改属性“children”为分类型。这样得到的数据文件为“”，含600条实例。用“explorer”打开刚才得到的“bank.arff”，并切换到“cluster”。点“choose”按钮选择“simplekmeans”，这是weka中实现k均的算法。点击旁边的文本框，修改“numclusters”为6，说明我们希望把这600条实例聚成6类，即k=6。下面的“seed”参数是要设置一个随机种子，依此产生一个随机数，用来得到k均算法中第一次给出的k个簇中心的位置。我们不妨暂时让它就为10。选中“cluster mode”的“use training set”，点击“start”按钮，观察右边“clusterer output”给出的聚类结果。也可以在左下角“result list”中这次产生的结果上点右键，“view in separate window”在新窗口中浏览结果。结果解释首先我们注意到结果中有这么一行：within cluster sum of squared errors: 1604.7416693522332这是评价聚类好坏的标准，数越小说明同一簇实例之间的距离越小。也许你得到的数会不一样；实际上如果把“seed”参数改一下，得到的这个数就可能会不一样。我们应该多尝试几个seed，并采纳这个数最小的那个结果。例如我让“seed”取100，就得到within cluster sum of squared errors: 1555.6241507629218我该取后面这个。当然再尝试几个seed，这个数可能会更小。接下来“cluster centroids:”之后列出了各个簇中心的位置。对于数型的属性，簇中心就是它的均（mean）；分类型的就是它的众数（mode），也就是说这个属性上取为众数的实例最多。对于数型的属性，还给出了它在各个簇里的标准差（std devs）。最后的“clustered instances”是各个簇中实例的数目及百分比。为了观察可视化的聚类结果，我们在左下方“result list”列出的结果上右击，点“visualize cluster assignments”。弹出的窗口给出了各实例的散点图。最上方的两个框是选择横坐标和纵坐标，第二行的“color”是散点图着色的依据，默认是根据不同的簇“cluster”给实例标上不同的颜色。可以在这里点“save”把聚类结果保存成arff文件。在这个新的arff文件中，“instance_number”属性表示某实例的编号，“cluster”属性表示聚类算法给出的该实例所在的簇。----整理自

D0389632Win7 完全删除cygwin转载自1.为什么cygwin难以删除正常情况下，选择 cygwin的反安装时最好的选择。重装系统后，反安装被破坏之后，删除就有点麻烦了cygwin模拟了linux的权限管理体系，这跟windows的默认权限管理有些冲突。当使用右键查看属性中的安全选项夹时，可以看到“组或用户名”一栏，有无法识别的用户（带有问号），它们是我重装系统以前的用户，那串数字是唯一识别号，尽管我的用户名没有改，但是它的唯一的识别号是完全不同的，所以目前登录的帐号对文件没有修改和删除的权限。2.如何删除cygwinwin7下对于无法修改或删除的文件夹及文件的处理方式，一般是获取权限再进行修改，包括两个步骤：一是修改文件夹及其文件的所有者，而是当前用户对其的访问权限。win7下如果要删除一个文件夹的话，需要其文件夹下的所有文件和文件夹都修改了权限才能顺利删除，但是通过图形界面，对一个文件夹进行所有者和用户权限修改仅对该文件夹下的第一层文件和文件夹有效，而不能修改处于更深层次的文件及文件夹。而cygwin安装目录的文件众多，文件树深度大，手动修改起来就显得麻烦，耗时，因此建议选择第2中方法，程序修改。（1）手动删除：麻烦、耗时、痛苦a.右键点要删除cygwin文件夹，依次选属性-安全-高级-所有者-编辑，将所有者改为你的登录帐户，勾选下方“替换子容器和对象的所有者”。b.在 属性-安全-高级对话框中选 审核选项卡，点继续，点添加，输入everyone，点确定添加everyone帐户，在弹出的对话框中将完全控制后面的允许勾上，勾选“使用可从此对象继承的权限替换所有子对象权限”,确定。 接下来就可以顺利删除cygwin文件夹了。手动删除是件非常痛苦的事。（2）程序删除：方便、快捷、轻松a. 使用takeown.exe 对cygwin文件夹所有子目录及子文件修改所有者。 takeown.exe参数格式意义，可上网搜索。 进入cygwin的安装目录下，然后再命令行输入：b. 用win7系统提供的命令修改用户对文件夹所有子目录及其子文件的访问权限。命令为icacls,参数格式及其意义可上网搜索。以上两个步骤都需要一定的处理时间，2,3分钟左右。好了，终于可以完整删除整个cygwin文件夹。

D0089166MFC 打印程序引言打印程序的编写在windows程序设计中非常有用，针对不同的用户需要，通常用sdk方式实现打印代码量比较大，而且要对打印流程的底层有非常清楚的了解，需要一个程序员有非常深入的打印方面的知识，利用mfc提供的文档视图结构，不但可以实现一些常用的标准界面元素，把数据的处理的界面的处理分离出来，而且其提供的打印功能更是方便快捷，功能强大。打印程序的编写本质是是一种gdi绘图，只是绘图的对象是在打印机的设备描述表，如果对于屏幕的gdi绘图比较熟悉的读者，相信掌握打印程序的编写应该比较容易。1、文档视图结构的程序的打印程序的编写通常情况下，一个结构组织的比较好的mfc程序是基于文档视图结构的，这一框架结构给我们提供了很多功能，比如菜单，注册表的关联，文件类型的注册，打印功能，只要我们善于发掘，这些都可以为我们所用，但我们现在只关心如何使用mfc提供的结构来实现打印功能。在编写打印程序之前，有必要先介绍一下mfc的框架结构，其中的文档视图结构又是这个框架的重点，我们通过分析mfc实现的视图类的原代码就可以看到一个打印程序的执行流程。读者也可以看侯俊杰的《深入浅出mfc》,上面有关于mfc打印的详细流程解释,下面是mfc的打印的函数的实现，该函数名为onfileprint它不是一个虚函数，而是响应缺省的command消息的处理函数，因为mfc提供了向导生成的菜单和工具栏，关于打印的命令id为id_file_print ，而在视图类的messagemap里有这样一项，on_command (id_file_print, cview::onfileprint)，因此实际使用的过程中可以不用原来的id, 而使用自己的id如id_myprint,再在messagemap里加入on_command (id_myprint, cview::onfileprint)即可完成原来一样的功能。viewprnt.cpp中有cview的onfileprint的函数的具体实现，viewprnt.cpp的位置读者自己用windows查找就能找到，这是mfc的源代码，本文把其中的主要代码列出放在下面，直接看下面的分析：01.void cview::onfileprint()02.{03.// get default print info if (onprepareprinting(printinfo)) {04.if (dlg.domodal() != idok)05.return;06.} onbeginprinting(dcprint, printinfo);07.onpreparedc(dcprint, printinfo);08.onprint(dcprint, printinfo);09.onendprinting(dcprint, printinfo); 10.// clean up after printing }其中加粗的代码行为可以重载的虚函数，根据不同的用户，其内容会不同。对于 onprepareprinting() 函数的具体内容必须有 return doprepareprinting(pinfo);这是在一个打印过程中最先调用的。当然也可以包含一些其它的打印初始化操作。我们最主要的是要重载三个函数：1.onbeginprinting();2.onprint();3.onendprinting();而以 onprint 最为复杂，它是我们要写大量代码实现我们打印功能的地方。对于默认的onprint实现是调用cview的ondraw，也就是和绘制视图类的客户区的内容完全相同的方法来在打印机上绘图。实际中我们在两种地方绘图的内容是完全不同的，可能用户在客户区绘的是一个曲线，而在打印机上要绘制表和数据。onprint(cdc* pdc, cprintinfo* pinfo)的第二个参数是一个cprintinfo类型的指针，我们可以从这个指针指向的对象中获得很多信息，如总共的页数，当前的页数，这在打印页眉页脚时可能是很有用的信息。cprintinfo的定义如下：01.struct structcprintinfo // printing information structure02.{03.cprintinfo();04.~cprintinfo();05.cprintdialog* m_ppd;   // pointer to print dialog06.bool m_bdocobject;    // true if printing by iprint interface07.bool m_bpreview;     // true if in preview mode08.bool m_bdirect;     // true if bypassing print dialog09.bool m_bcontinueprinting;// set to false to prematurely end printing10.uint m_ncurpage;     // current page11.uint m_nnumpreviewpages; // desired number of preview pages12.cstring m_strpagedesc;  // format string for page number display13.lpvoid m_lpuserdata;   // pointer to user created struct14.crect m_rectdraw;    // rectangle defining current usable page area15.// these only valid if m_bdocobject16.uint m_noffsetpage;   // offset of first page in combined iprint job17.dword m_dwflags;     // flags passed to iprint::print18.void setminpage(uint nminpage);19.void setmaxpage(uint nmaxpage);20.uint getminpage() const;21.uint getmaxpage() const;22.uint getfrompage() const;23.uint gettopage() const;24.uint getoffsetpage() const;25.};onbeginprinting()通常用来设定要打印的总页数，以及一些和页面尺寸有关的初始化工作，在onbeginprinting()中设定打印的页数是必要的，默认的页数是只有一页，如果开发人员打印的页数大于1，则必须在此函数中设定打印的页数。然后在onprint(cdc* pdc, cprintinfo* pinfo)中用pinfo- m_ncurpage获取当前的页码，根据当前的页码打印该页相应的内容。onendprinting用来释放在onbeginprinting中申请的资源，如果没有申请，则不需重载该函数。关于打印预览只需要将自己的执行打印预览功能的命令id和cview::onfileprintpreview关联起来就行了，具体方法是在用户的视图类的messagemap中加入：1.on_command(id_file_print_preview, cview::onfileprintpreview);其中id_file_print_preview是默认的id，开发人员也可以使用自己的id。其实只要重载了onprint函数，在打印和打印预览中就可以重用该函数了。到现在为止，相信读者已经对利用mfc的文档视图结构来实现一个包含打印和打印预览功能的程序有了一个总体的认识了，本文还针对该方法给出了一个示例代码，代码来自jeff prosise 的《mfc windows程序设计》，见参考文献[1]。2、没有文档视图结构的程序中利用mfc进行打印程序的编写如果程序不是文档视图结构的，我们要使用mfc来进行打印，则可以通过建立一个虚拟的文档视图结构来进行打印，其实mfc的打印的强大功能是在cview里提供的，而cview类的对象是一个子窗口，它必须是某一个框架窗口的子窗口，而在对话框程序中，我们只需要打印，而不需要显示这个框架窗口和视图。我们以按下按钮打印来执行打印程序，例如按钮为id为idc_pnt，消息相应函数为onpnt()，即：1.on_bn_clicked(idc_pnt, onpnt)；需要在onpnt中建立一个框架窗口，同时使某个cview类的对象为该窗口的子窗口。因此笔者建立了两个类，一个为框架窗口类cprintframe，另一个为cprintview，具体的内容见示例代码。在新建一个用于打印的虚拟框架窗口时，需要将执行打印的对话框的指针传给框架窗口，这以便在对话框来响应wm_begin_printing和wm_end_printing消息，使对话框可以完成打印的初始化和释放操作。在执行一个打印任务时，将打印的流程交给cview来进行，而这个cview是虚拟的，只是用来完成打印一些操作，其它内容则完全不负责处理，而当要执行cview::onprint时，则又将处理的具体内容传回到对话框，而对话框则只需要响应wm_my_print消息即可：1.pframe-m_pcallerdlg-sendmessage(wm_my_print,(wparam) pdc, (lparam) pinfo);使打印的具体处理又传回到对话框中，使开发人员根据具体的需要写wm_my_print的处理函数就可以实现打印，而cview::onprint(cdc* pdc, cprintinfo* pinfo)的参数也从wm_my_print的消息参数传出来，在用户的对话框程序中,需要写的代码就很少，主要有以下几个步骤，1.建立一个cprintframe的对象,设该对象的指针为pframe，并将对话框的指针传给该对象的m_pcallerdlg，即pframe-m_pcallerdlg = this；2.调用对象的create函数创建框架窗口；例如pframe-create(null,频谱打印,ws_overlappedwindow,crect(0,0,0,0));3.如果要执行打印，则调用pframe-m_pview-onmyprint();4.如果要执行打印预览，则调用：1.pframe-m_pview-onmyprintpreview();    例如：01.void cdlgprintdlg::onprint() //执行打印功能02.{03.cprintframe *pframe = new cprintframe;04.pframe-m_pcallerdlg = this;05.pframe-create(null,curve06.print,ws_overlappedwindow,crect(0,0,0,0));07.pframe-m_pview-onmyprint();08.}09.10.void cdlgprintdlg::onprintpreview() //执行打印预览功能11.{12.cprintframe *pframe = new cprintframe;13.pframe-m_pcallerdlg = this;14.pframe-create(null,curve print15.preview,ws_overlappedwindow,crect(0,0,0,0));16.pframe-m_pview-onmyprintpreview();     }5.在对话框中响应 wm_begin_printing， wm_end_printing，wm_my_print消息，分别完成打印的初始化，释放和具体的打印操作；如在示例程序中添加了三个消息响应函数来执行该功能。1.on_message(wm_begin_printing,onbeginprinting)2.on_message(wm_end_printing,onendprinting)3.on_message(wm_my_print,onmyprint)其中onmyprint是跟具体要打印什么内容有关的开发人员要重点完成的代码，可以打印表，图片，数据，只要gdi绘图可以进行的操作在这里都可以完成。由于打印预览的一部分工作在cview类里完成，因此在用户程序中只需要相应wm_my_print消息就可以执行打印预览的功能，而不需要另外编写打印预览代码。本文提供的cprintframe和cprintview类是连个可重用的类，开发者只需要把这两个类对应的四个文件拷贝到工程文件所在目录中(printframe.h, pringtview.h,printframe.cpp, printview.cpp)，并将这四个文件加入工程，并在需要执行打印功能的代码处加入1.#include printframe.h2.#include printview.h然后按照上述5个步骤进行即可以实现一个功能完整的打印程序，利用上述类实现对话框打印不但节省开发者许多时间，而且功能很强大，能达到很专业的水平，但是该方法有一个缺点，笔者发现如果开发者使用静态连接的mfc库时则会出错，只适用于use mfc in a shelled dll情况，而且必须使程序为debug版本的。3、示例代码的执行效果图1 执行打印功能的对话框当按下打印预览后则会产生一个框架窗口，显示打印预览的内容，如图2所示：图2 打印预览效果图可以在上图的界面上按两页同时对两页预览，如图3所示：图3 两页同时预览效果图但有一点需要注意，在预览界面上的打印按钮不可用，如果按该打印钮则直接等于将预览窗口关掉，因此要执行打印功能必须另外在对话框的界面上放一个打印按钮，如果执行了打印功能，则会弹出一个选择打印机的对话框，如图4所示。这个对话框是mfc的打印结构内置的，不可以消除，当用户选择了正确的打印机后则可以打印出具体的内容了。图4 打印机选择对话框4、 结束语本文从分析mfc的原代码入手，利用mfc的cview类提供的打印和打印预览功能进行了在对话框中的打印和打印预览。利用面向对象的c写了两个可重用类cprintframe和cprintview，实现在对话框中的打印和打印预览功能，极大的简化了对话框打印程序的编写。参考文献[1]jeff prosise，programming windows with mfc - 2nd ed，microsoft press，1999.[2]charles petzold， programming windows-5th ed，microsoft press，1998.[3]侯俊杰，深入浅出mfc,华中科技大学出版社，1999

D0776559android获取屏幕宽高获取屏幕宽高[java]//获取屏幕宽高（方法1）intscreenwidth=getwindowmanager().getdefaultdisplay().getwidth();//屏幕宽（像素，如：480px）intscreenheight=getwindowmanager().getdefaultdisplay().getheight();//屏幕高（像素，如：800p）log.e(taggetdefaultdisplay,screenwidth=screenwidth;screenheight=screenheight);//获取屏幕密度（方法2）displaymetricsdm=newdisplaymetrics();dm=getresources().getdisplaymetrics();floatdensity=dm.density;//屏幕密度（像素比例：0.75/1.0/1.5/2.0）intdensitydpi=dm.densitydpi;//屏幕密度（每寸像素：120/160/240/320）floatxdpi=dm.xdpi;floatydpi=dm.ydpi;log.e(tagdisplaymetrics,xdpi=xdpi;ydpi=ydpi);log.e(tagdisplaymetrics,density=density;densitydpi=densitydpi);screenwidth=dm.widthpixels;//屏幕宽（像素，如：480px）screenheight=dm.heightpixels;//屏幕高（像素，如：800px）log.e(tagdisplaymetrics(111),screenwidth=screenwidth;screenheight=screenheight);//获取屏幕密度（方法3）dm=newdisplaymetrics();getwindowmanager().getdefaultdisplay().getmetrics(dm);density=dm.density;//屏幕密度（像素比例：0.75/1.0/1.5/2.0）densitydpi=dm.densitydpi;//屏幕密度（每寸像素：120/160/240/320）xdpi=dm.xdpi;ydpi=dm.ydpi;log.e(tagdisplaymetrics,xdpi=xdpi;ydpi=ydpi);log.e(tagdisplaymetrics,density=density;densitydpi=densitydpi);intscreenwidthdip=dm.widthpixels;//屏幕宽（dip，如：320dip）intscreenheightdip=dm.heightpixels;//屏幕宽（dip，如：533dip）log.e(tagdisplaymetrics(222),screenwidthdip=screenwidthdip;screenheightdip=screenheightdip);screenwidth=(int)(dm.widthpixels*density0.5f);//屏幕宽（px，如：480px）screenheight=(int)(dm.heightpixels*density0.5f);//屏幕高（px，如：800px）log.e(tagdisplaymetrics(222),screenwidth=screenwidth;screenheight=screenheight);获取控件的宽高，一般来说，我们在oncreate里面得到的控件的宽高全是０.采用下面的方法，可以得到真实的宽高[csharp]//------------------------------------------------方法一intw=view.measurespec.makemeasurespec(0,view.measurespec.unspecified);inth=view.measurespec.makemeasurespec(0,view.measurespec.unspecified);imageview.measure(w,h);intheight=imageview.getmeasuredheight();intwidth=imageview.getmeasuredwidth();textview.append(|nheight,width);　　　　此方法会加载onmeasure三次//-----------------------------------------------方法二viewtreeobservervto=imageview.getviewtreeobserver();vto.addonpredrawlistener(newviewtreeobserver.onpredrawlistener(){publicbooleanonpredraw(){intheight=imageview.getmeasuredheight();intwidth=imageview.getmeasuredwidth();textview.append(|nheight,width);returntrue;}});　　　　此方法会加载onmeasure二次，但是回调函数会回调很多次　　　　//-----------------------------------------------方法三viewtreeobservervto2=imageview.getviewtreeobserver();vto2.addongloballayoutlistener(newongloballayoutlistener(){@overridepublicvoidongloballayout(){imageview.getviewtreeobserver().removeglobalonlayoutlistener(this);textview.append(|n|nimageview.getheight(),imageview.getwidth());}});　　　　prename=codeclass=csharp　　　此方法会加载onmeasure二次，但是回调函数只回调一次/prep/ppre/prebrbrp/p获取屏幕的宽度和高度：方法一:1234567891011121314    方法二：1234567

D0802938多点触控 实现图片自由缩放由于需要真机测试, 所以没有弄效果图..1, 建立一个类multitouch 继承 imageview, 并在xml使用, 获取要缩放图片. 如果图片的宽/高大于屏幕宽/高, 那么我们进行缩放,并移动到屏幕中心点.  那么问题来了. 如果我们在构造器中直接获取宽度 那么可能会获取不到. 我们需要知道布局什么时候加载完成. 这时候就需要用到一个接口ongloballayoutlistener (全球布局监听)  实现ongloballayout() 方法. 并且需要在view 从window出现时 监听它, 从window时 移除.于是对图片初始化的操作 都会在ongloballayout()内执行.2,我们还需要实现 onscalegesturelistener 接口 来对 多点触控进行操作...  很方便3. 把touch 事件 交给onscalegesturelistener . 下面贴代码

D0379964python创建单例模式的5种方法所谓单例，是指一个类的实例从始至终只能被创建一次。方法1如果想使得某个类从始至终最多只有一个实例，使用__new__方法会很简单。python中类是通过__new__来创建实例的：12345678910111213结果：29922256 banana29922256通过__new__方法，将类的实例在创建的时候绑定到类属性_inst上。如果cls._inst为none，说明类还未实例化，实例化并将实例绑定到cls._inst，以后每次实例化的时候都返回第一次实例化创建的实例。注意从singleton派生子类的时候，不要重载__new__。方法2：有时候我们并不关心生成的实例是否具有同一id，而只关心其状态和行为方式。我们可以允许许多个实例被创建，但所有的实例都共享状态和行为方式：123456将所有实例的__dict__指向同一个字典，这样实例就共享相同的方法和属性。对任何实例的名字属性的设置，无论是在__init__中修改还是直接修改，所有的实例都会受到影响。不过实例的id是不同的。要保证类实例能共享属性，但不和子类共享，注意使用._shared_state,而不是borg._shared_state。因为实例是不同的id，所以每个实例都可以做字典的key：12345678910111213结果：012如果这种行为不是你想要的，可以为borg类添加__eq__和__hash__方法，使其更接近于单例模式的行为：1234567891011121314151617181920212223242526结果：222所有的实例都能当一个key使用了。方法3当你编写一个类的时候，某种机制会使用类名字，基类元组，类字典来创建一个类对象。新型类中这种机制默认为type，而且这种机制是可编程的，称为元类__metaclass__ 。1234567891011121314结果：34248016 34248016id是相同的。例子中我们构造了一个singleton元类，并使用__call__方法使其能够模拟函数的行为。构造类a时，将其元类设为singleton，那么创建类对象a时，行为发生如下：a=singleton(name,bases,class_dict),a其实为singleton类的一个实例。创建a的实例时，a()=singleton(name,bases,class_dict)()=singleton(name,bases,class_dict).____()，这样就将a的所有实例都指向了a的属性_instance上，这种方法与方法1其实是相同的。方法4python中的模块module在程序中只被加载一次，本身就是单例的。可以直接写一个模块，将你需要的方法和属性，写在模块中当做和模块作用域的变量即可，根本不需要写类。而且还有一些综合模块和类的优点的方法：12345678910111213python并不会对sys.modules进行检查以确保他们是模块对象，我们利用这一点将模块绑定向一个类对象，而且以后都会绑定向同一个对象了。将代码存放在single.py中：123consterror del single.aconsterror方法5最简单的方法：123将名字singleton绑定到实例上，singleton就是它自己类的唯一对象了。

D0148582进程间通信 - 动态链接库实现引子前面介绍的几种用于实现进程之间通信的方法都是比较正统的方式，像剪贴板，命名管道这些都还是用得比较多的，而这里将介绍的是一种比较偏门的方法来实现进程间的通信，所谓偏门呢，自然就是用的少，能够不用就不要使用。其实这种方法就是通过动态链接库来实现进程间的通信。动态链接库（dll）概述既然是要通过动态链接库来实现进程间的通信，那么这里如果不来介绍一下动态链接库的话，怎么也说不过去的。动态链接库是windows操作系统的基础，其中windows api基本上都是以动态链接库的形式来提供的，通常来说动态链接库是不能够直接运行，也不能够直接接受消息的，它们是一些独立的文件（后缀名一般为.dll，当然还有其他的一些后缀名也是可以的），其中包含能被可执行程序或其他dll调用来完成某项工作的函数，也就是说动态链接库也就是由一些函数组成而已。并且只有在其他模块调用动态链接库中的函数时，动态链接库才发挥作用，在实际的编程中，通常可以把完成某种功能的函数放在一个动态链接库中，然后提供给其他函数调用。当这个访问了动态链接库的进程被加载时，系统会为这个进程分配4gb的私有地址空间，然后系统就会分析这个可执行模块，找到这个可执行模块中所调用的dll，然后系统就负责搜索这些dll，找到这些dll后便将这些dll加载到内存中，并为它们分配虚拟的内存空间，最后将dll的页面映射到调用进程的地址空间中，dll的虚拟内存有代码页和数据页，它们被分别映射到进程 a的代码页面和数据页面，如果这时进程 b也启动了，并且进程 b也需要访问该dll，这时，只需要将该dll在虚拟内存中的代码页面和数据页面映射到第二个进程的地址空间即可。这也表明了在内存中，只需要存在一份dll的代码和数据，多个进程共享dll的同一份代码，很明显这样做可以节省内存空间的。但是在windows下，由于系统会为每一个进程分配4gb的私有地址空间，而dll中的代码和数据也只是映射到了这个私有地址空间中，所以这些应用程序之间还是不能够相互影响的，也就是说多个应用程序虽然是可以共享同一个dll中的相同的代码的，但是dll为每一个进程保存的数据都是不相同的，并且每一个进程都为dll使用的全部数据分配了自己的地址空间，举个最简单的例子，我的dll中有一个函数为intadd（int num1 , int num2），这个函数的作用是实现num1和num2相加并返回相加后的结果。然后我有一个进程 a 使用了这个dll，并且其调用了函数add（10， 20）,然后我还有一个进程 b其也使用了这个dll，并且其调用了函数add（30， 40）,那么对于进程 a中的数据10和20其实是保存在进程 a的私有地址空间中的，而对于进程 b中的数据30和40则是保存在进程 b的私有地址空间中的，上面这个简单的例子表明如果单单用这种简单的使用动态链接库的方式是不能够实现进程之间的通信的。动态链接库中共享内存的实现如果想利用动态链接库来实现进程间的通信的话，那么有一种方案可以试一试，即从系统为动态链接库分配的那一块内存（系统需要将动态链接库加载到内存中）下手，由于在内存中，动态链接库其实只存在一份，其被所有需要调用该动态链接库中的函数的模块或者简单说是可执行程序所共享，既然是共享的话，如果我在系统给动态链接库分配的这块内存中保存数据，那岂不是可以被所有访问该动态链接库的可执行程序所获取或者说设置。这样的话，我就可以使用进程 a来设置好这个共享内存中的数据，然后进程 b就可以读取这个共享内存中的数据了，这不是也可以实现进程间的通信嘛，这样看来的话，其思路其实和使用剪贴板是一模一样的了。也是采用一块两个进程共享的内存来作为存放数据的中介。示例：动态链接库实现进程间通信共享 dll 实现：新建动态链接库项目步骤：项目结构：sharedll.hdll.cpp进程 a 实现：（简单 console 程序）项目结构：sharedll.hdllprocessa.cpp进程 b 实现：（简单 console 程序）项目结构：sharedll.hdllprocessb.cpp需要将 dll 项目中的 dll . dll 和 dll . lib 两个文件，分别拷贝到项目 dllprocessa 和 dllprocessb 的根目录下。然后分别编译 dllprocessa 和 dllprocessb 两个项目，最后将 dll . dll 和 dll . lib 以及 dllprocesa . exe 和 dllprocessb . exe 拷贝到同一目录下面，比如：（这样可以确保两个进程访问到的是同一个动态链接库）效果展示：首先运行 dllprocessa . exe 文件并设置共享数据为 8 ：然后启动 dllprocessb . exe 文件（可以看出其读出的为 8 ）：然后再在 dllprocessb . exe 中设置数据为 16 ：然后再在 dllprocessa . exe 中按下回车键（此时可以看到进程 a 读取到的数据位 16 了）：结束语从上面的这个效果展示中可以看出，我们确实通过动态链接库实现了进程 a和进程 b之间的通信，前面说过使用动态链接库来实现进程之间的通信是一个偏方，通过这个demo呢，我们也是可以看出这种方式的局限性的，第一，使用动态链接库来实现进程间的通信的话，首先必须要求通信的双方进程都访问了这个动态链接库。第二，这种方式只适用于本地进程之间的通信，其不能实现跨网络的通信。关于进程之间通信呢，前前后后介绍了五种方法，其中各有各的优点，也各有各的局限性，至于具体要使用那一种的话，那还请各位看官自行斟酌，然后选用合适的方案 ！！！

D0339360自动构建项目神器--jenkins安装、配置、任务配置由于之前公司使用windows的任务管理器去构建，也没有任何提醒，一但发生代码错误，还需要在发现问题后去检查哪里有错误，特别不方便，于是想到使用自动构建工具---jenkins。安装jenkins的安装没有什么好说的，换个目录，然后一路下一步就可以了，我安装的版本是jenkins-1.596.3。安装完成后，运行jenkins.exe，就会以一个服务的形式启动起来了，这时大家可以通过访问来查看是否安装成功。这里我已经创建了一个任务，如果第一次进是不会有的。配置点击系统管理，就可以对全局环境进行统一的配置了这里我只对比较有用的参数进行一下说明，其他的还没有摸索。这两个参数是设置java_home和ant_home的，写成本机的绝对路径就可以了，主要是保证jenkins在编译时可以直接找到依赖的程序。配置对外访问的路径和管理员的邮箱，访问路径是给其他机器访问用的，管理员邮箱是在有问题时进行邮件提醒。配置邮件服务器和地址配置smtp的地址，然后默认的用户后缀，这些配完后，可以用下面的test e-mail recipient发一封测试邮件来看看是否配置成功了任务配置全局配置说明完后，我们说一下构建任务的配置，首先先生成一个。一般不用maven的话就选第一个就行，最后的那个是方便你复制任务用的（实际环境中，多个定期任务很平常）。首先是先输入个项目名称，其他的意义不是很大，这里先配置代码服务器由于我用的是微软的vsts，所以就拿它举例了，不过svn和git大同小异，首先都是配置代码服务器的地址，然后是你要打包程序的路径（服务器路径哦），然后是你的用户名和密码，这样jenkins就能通过这些配置去代码服务器取代码了。上面是两种定时器，第一种是可以设定一个周期，让jenkins去自动执行，比如我这里就设定了每天的17:26来执行任务。poll scm是用于检查代码服务器的代码是否有改变，如有改变就执行编译任务的，可以设置一个周期，比如每30分钟检查一次。*/30 * * *执行ant任务的话，一定要选则这个。如果你项目下的构建文件不是build.xml或不在这的话,需要在build file选项中写出你的编译文件路径.最后是配置邮件通知,这样在成功或者失败的时候,都会有一个主动的推送提醒,特别方便.点击保存后,一条任务就生成了.可以点击这个按钮让任务立即执行这样构建任务就会在你设置的参数中循环的执行,而且编译无论成功还是失败都会发邮件主动提醒,这样就省去监控的时间和力气了.test e-mail recipient

D0934038maven的聚合与继承----继承user-parent的pom.xml文件中是使用dependencymanagement标签来管理子类可能用到的依赖包。注意父类项目的打包方式是packagingpom/packaging子项目中使用parent标签来继承。子项目中使用到的依赖只需要自定gav中的ga，也就是groupid和artifactid。这样做的好处是让maven来管理jar包，可以避免包的冲突。----聚合在父类的pom.xml中使用modules来聚合子模块。聚合后，只需要运行user-parent，也就是父项目的pom.xml命令mvncleaninstall，就会将聚合的项目模块也执行响应操作。

D0232706java基础之关键字标识符变量和数据类型1、关键字1.1、定义：java中，一些被java赋予特定含义，用作专门用途的字符串称为关键字。规则：关键字都是小写字母的（java语言是对大小写敏感的语言）。未在语法中定义，但也属于关键字的字符串叫保留字。（如：goto、const）。1.2、关键字的分类：1.2.1、定义数据类型的关键字：基本数据类型关键字（用于表示定义一个基本数据）：整型： byte 、short、 int、 long浮点型：float、double字符型：char布尔型：boolean引用数据类型关键字（用于表示一些特定java类型）：class(类）interface（接口）void（用于函数上表示无返回类型）用于定义数据类型的关键字：true、 false、 null1.2.2、定义流程控制的关键字判断：if、else、switch、case、default循环：while、do、for跳转：break、continue、return1.2.3、定义修饰符的关键字：定义访问权限修饰符的关键字public（公共的）、protected（受保护的）、private（私有的）定义功能修饰符的关键字static(静态的) 、 abstract(抽象的) 、final(最终的)、 synchronized(同步的)、 enum(枚举)1.2.4、表示类型关系的关键字extends(继承)、 implements(实现) 、this(当前引用) 、 super(父类引用) 、instanceof(判断对象类型) 、 new(建立实例)、 import（导入类）1.2.5、用于异常处理的关键字try(检查异常) 、 catch(捕获异常) 、 finally(最终执行)throw（抛出异常）、 throws（声明异常）1.2.6、其他关键字package(创建包)native(本地)strictfp(strictfloatpoint，精确浮点)transient(变量修饰符，用它声明一个实例变量，在对象序列化时不会被序列化)volatile(类型修饰符，用来修饰被不同线程访问和修改的变量)assert(断言)注：main不是关键字，却是被虚拟机所识别的一个名称。2、标识符2.1、定义：在程序中自定义的名称，称作标识符。2.2、作用：用于给包、类、类中成员的命名。2.3、合法标识符的定义规则：（1）标识符由英文字母大小写、数字、“_”、“$”组成。（2）数字不可以开头（3）不可以使用关键字2.4、标识符的命名规范：（1）为提高阅读性，命名要尽量有意义，最好见名知意。（2）包名命名规范：由一个或多个单词组成，所有单词字母都小写（如：aaabbbccc）（3）类名、接口名命名规范：由一个或多个单词组成，所有单词首字母大写（如：aaabbbccc）（4）变量名、函数名命名规范：从第二个单词开始单词的首字母大写（如：aaabbbccc）（5）常量名命名规范：所有单词字母都大写，单词之间加用“_”隔开（如：aaa_bbb_ccc）3、常量、变量3.1、常量的定义：java中固定不变的量、表示一个不能被改变的数。3.1.1、常量的分类：（1）数常量：java中所有整数和小数类型都是常量。（2）布尔型常量。布尔型常量只有两个，就是true和false。（3）字符常量。单个数字或字母、符号都是字符常量，用英文符号''进行标识（如：’a’）。（4）字符串常量。字符串常量是由一个或者多个字符组成，“”进行标识（如：”abc”）。（5）null常量。只有一个数：null，表示空。3.2、变量的定义：   变量就是将不确定的数据进行存储，变量是java程序中最基本的存储单元，其要素包括变量名、变量类型和作用域，可以简单理解为一个数可以被改变的量。3.2.1、变量的作用：   用来反复存放同一类型的数据，以便用于进行计算。变量是计算机分配的内存空间，使用前需要对其进行声明。3.2.2、声明变量的式：数据类型变量名=初始；或先声明后赋（如；数据类型变量名； 变量名=初始；）3.2.3、变量的分类：(1)按声明的位置分：局部变量：在方法或语句块内部定义的变量成员变量：在方法外部、类的内部定义的变量(2)按数据类型分：引用数据类型变量基本数据类型变量(3)还可以按用法分成静态变量和非静态变量4、数据类型4.1java语言是强类型语言，对每一中数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。java数据类型分基本数据类型和引用数据类型4.2基本类型：4.2.1数型：整数类型：byte、short、int（默认）、long浮点类型：float、double（默认）4.2.2字符型：char4.2.3布尔型：boolean4.3引用类型：类(class)、接口(interface)、数组([])、枚举(enum)4.4基本数据类型的长度4.4.1计算机都是用门电位对数据进行存储的，计算机硬件的电位数量是有限的，所以在使用计算机对数据进行计算时，要给数据定义一个相对固定的长度，一个固定长度的数据就是基本数据类型，计算机的最小存储单元是字节，每字节中包含八个电位。

D0462724Android 性能测试实践（四） 流量流量篇最近在研究ios 的性能测试，时间太紧没来得及发帖，加通宵挤出时间给大家分享一点东西，希望对大家有所帮助！android 2.2之前对于android2.2 的流量 版本以前的系统的流量信息都存放在 proc/net/dev（或者 proc/self/net/dev）文件下，读取文件然后对其进行解析就行了。读取某一个应用的流量，则读取proc/uid_stat/uid /tcp_rcv 文件进行解析（注：模拟器下不存在这个目录）。如需查看某个应用的流量信息，可以通过以下命令来实现：android 2.2之后我这里有两种办法：第一种通过pid下面的net/dev先找到应用的pid这边拿到pid:21896 然后在去/proc目录下的pid/net/dev面可以看到：这边的wlan0代表wifi 上传下载量标识! 上传下载量单位是字节可以/1024换算成kb这里可以看到下载的字节数 、数据包 和 发送的字节数 、数据包小技巧：wlan0这些如何初始化0 很简单 你打开手机飞行模式再关掉就清0了第二种通过proc/net/xt_qtaguid/stats在说第二种获取流量方法之前先给这边先给大家说下uiduid的获取可以在对应的pid下面去查看status，里面会查到uid下面这个方法是通过packagemanager去取：拿到uid后呢继续：其中第6和8列为 rx_bytes（接收数据）和tx_bytes（传输数据）包含tcp，udp等所有网络流量传输的统计。一个uid可能对应多个 进程，所以这有两行流量是累加的就求和就行。用java去获取打印我这边是用先获取pid然后调用！你可以把获取pid作为一个变量传到getflow里面来!我这边只获取下载流量，你可以把上传下载的流量都获取出来！获取每秒下载流量：场景设计拿到流量后在步骤前 将流量打印，再步骤完成后再打印一遍，再用步骤完成的流量减去之前的流量 得到这个步骤所消耗的流量！场景案例：拓展下面的方法都是集成在android 内部的方法：（仅供参考）android的trafficstats类前四个读取的/proc/net/dev里面的数据睡了。。。

D0827167java读取视频播放时间，很有用啊最近需要用java处理视频文件，读取视频的时长，在网上查，没找到合适的方法，用jmf吧，支持的式太少，用jni去读取其他语言写的api，但比较麻烦。无意中找到了jave这个开源的项目，看了看介绍，是用java来处理多种视频式之间的转换的，下载了下来，看了看，还真找到了获取视频时长的方法。记录下来，给需要朋友做个参考。下载jave的网址总共只有一个jar包，api也非常简单，不说了，贴代码：package com.jave;import it.sauronsoftware.jave.encoder;import it.sauronsoftware.jave.multimediainfo;import java.io.file;public class readvideo {public static void main(string[] args){file source = new file(e:\\测试视频\\r41.avi);encoder encoder = new encoder();try {multimediainfo m = encoder.getinfo(source);long ls = m.getduration();system.out.println(此视频时长为:ls/60000分(ls`000)/1000秒！);} catch (exception e) {e.printstacktrace();}}}jave支持的式很多，有几十种，有兴趣的朋友可以试试。

D0450271grep 后加单引号、双引号和不加引号的区别转自：单引号：可以说是所见即所得：即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号''是全引用，被单引号括起的内容不管是常量还是变量者不会发生替换。双引号：把双引号内的内容输出出来；如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来。双引号是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。不加引号：不会将含有空的字符串视为一个整体输出,如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来，如果字符串中带有空等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以用。使用规则：一般常量用单引号''括起，如果含有变量则用双引号括起。最大不同：单引号与双引号的最大不同在于双引号仍然可以保有变数的内容，但单引号内仅能是一般字元，而不会有特殊符号使用举例：“”号里面遇到$，\等特殊字符会进行相应的变量替换‘’号里面的所有字符都保持原样对于字符串，两者相同匹配模式也大致相同但有一些区别非常容易混淆grep $a file #引用变量a,查找变量a的grep '$a' file #查找“$a”字符串grep \\ file #grep: trailing backslash（不知原因）grep '\\' file #查找‘\’字符1、$美元符2、\反斜杠3、`反引号4、　双引号这四个字符在双引号中是具有特殊含义的，其他都没有，而单引号使所有字符都失去特殊含义如果用双引号，查找一个\，就应该用四个\:grep \\\\ file这样就对了，这样等同于：grep '\\' file第一条命令shell把四个\,转义成2个\传递给grep，grep再把2个\转义成一个\查找第二条命令shell没转义，直接把2个\传递给grep，grep再把2个\转义成一个\查找其实grep执行的是相同的命令

D0428411先赚钱再伟大这个世界上很少有成功改变世界的创业者，在创业之初就抱着改变世界的理想，改变世界只是他们创业的结果而并非他们本心。甚至相反，那些抱着改变世界理想的创业者，一般都会被无谓的道德感所束缚，这是一个很可怕的束缚。都知道乔布斯是从车库起家的，但是乔布斯在车库里只是想鼓捣出一个能骗投资人钱的玩意儿，苹果当时的联合创始人之一——设计了苹果 logo 的人——以 800 美元的价，将自己手中的股权如烫手山芋一般的全部卖给乔布斯，因为在韦恩看来，乔布斯当时所做的事情就是典型的敲诈。都知道比尔·盖茨是会码代码的，但是他的第一桶金是靠低价买入了 dos 再高价卖出去赚来的。比尔盖茨退学创业成为20世纪首屈一指富豪的故事你耳熟能详，但是你不知道的是，当时比尔盖茨退学之后的工资并不高，职业发展路径也不太允许他成为一个亿万富翁。1980年8月，盖茨与ibm签订合同，同意为ibm的pc机开发操作系统。随后他以 5 万美元价从一家即将倒闭的软件公司手中购买了一款名 qdos 的操作系统，对其稍加改进后，将该产品更名为 dos，并授权给 ibm 使用——嗯，这个和前两年国内某教授买 moto 的芯片磨掉 logo 宣称自主知识产权的没什么太大区别，当时他也只想做一锤子买卖。facebook 就更是如此啦，流氓黑帽马克·扎克伯只是为了报复前女友才做出的 facebook 原形——那个盗取哈佛全校女生照片给所有人打分的网站，除了侵犯隐私权之外真的看不出来人任何伟大。作为一家成熟而伟大的企业，以上的任何一个公司都不可能像他们建立之初的那样去“作恶”了。因此，永远不要心想成为一家伟大的公司，因为伟大公司一开始都不是这么想的。只有伟大和光明、正确可以并列，钱不能，但钱才是这些的支撑。转自：（作为创业者，陈安妮做错了什么？） 更多请点击转发的url

D0482340正则中需要转义的特殊字符小结正则表达式中的特殊字符，就是一些有特殊含义的字符，如“*.txt”中的*，简单的说就是表示任何字符串的意思如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\。ls \*.txt。正则表达式有以下特殊字符。需要转义特别字符说明$匹配输入字符串的结尾位置。如果设置了regexp对象的multiline属性，则$也匹配‘|n'或‘|r'。要匹配$字符本身，请使用\$。( )标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用\(和\)。*匹配前面的子表达式零次或多次。要匹配*字符，请使用\*。匹配前面的子表达式一次或多次。要匹配字符，请使用\。.匹配除换行符|n之外的任何单字符。要匹配.，请使用\。[ ]标记一个中括号表达式的开始。要匹配[，请使用\[。?匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配?字符，请使用\?。\将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，‘n'匹配字符‘n'。'|n'匹配换行符。序列‘\\'匹配“\”，而‘\('则匹配“(”。^匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配^字符本身，请使用\^。{ }标记限定符表达式的开始。要匹配{，请使用\{。|指明两项之间的一个选择。要匹配|，请使用\|。所以是代码如下:* . ?  $ ^ [ ] ( ) { } | \ /构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与操作符将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

D0170022早期工作项目总结2011.3-2011.5 rtsp学习rtsp： 多媒体实时播放控制协议，用户可以pause/continue。主要的方法有：options : 询问有哪些方法可用describe： 获取多媒体初始化信息，使用sdp协议setup：设置会话属性，传输模式和 与server建立会话连接（包括客户端端口 和 服务器端端口 的分配）teardown, play, pause.2011.1-2011.3 内核驱动学习笔记1. 写内核驱动代码有一个固定的模式， 对应的makefile文件也是。2. j建立内核驱动，需要获取设备编号。 （ ls -l /dev/ 可以看到）register_chrdev_region() / unregister_chrdev_region() / alloc_chrdev_region(). alloc_chrdev_region()动态获得编号，不能提前在/dev下创建节点，需要先读取 /proc/modules文件。3. 内核在内部使用 struct cdev 结构体来表示字符设备。cdev_init() / cdev_add() 用于向内核添加一个驱动设备，它的返回就表示某个字符设备。cdev_del()定义自己的类型，包含struct cdev类型。 用户在open()操作的时候， 让 file-private_data指向这个struct cdev实例。 之后read() / write() / ioctl() 都可以通过 file来坐坐cdev实例。  copy_to_user()/ copy_from_user() 用于内核空间与用户空间的数据拷贝。4. 并发： 互斥锁（init_mutex/ down/ up)  completion机制: init_completion/ wait_for_completion5. 字符设备：是一种可以当作一个字节流来存储的设备。例如：键盘  快设备： 系统中能够随机访问固定大小数据片的设备叫做快设备。例如硬盘2010.3-2010.12 mytest测试框架mytest 是三星内部使用的测试框架，类于google的 gtest。 那为什么我们不使用gtest，而是要自己搞一套测试框架了？ 基于以下几个方面的考虑：1. 压力测试。 我们某些测试用例，需要连续测试1万次或者10万次，查看性能及内存泄漏。 需要在配置文件中设置测试用例重复的次数。2. 环境： 要同时支持arm平台及window平台。 嵌入式平台很复杂，测试工具只能以动态库的形式嵌入到系统中，而不能以exe形式运行。3. 配置文件： 我们需要有配置文件， 你们可以配置运行哪些测试用例，运行多少次。4. 由于window平台上面没有默认的正则表达式库，我们这里用到了 boost 你们的 regex库。项目架构：如上图所述，1. 需要一个manage作为管理类，下面有分为 config manage, output manage， runner manage 三个类。2. 有一个操作系统的适配层。用于保证对上层提供一致的接口，保证与操作系统无关。3. 配置文件 gtf.conf 里面列举了ts/tc ，测试次数，输出文件名 等信息。可能我们写了10个测试用例，保存在全局的list中， 但我们只想测试其中的5个测试用例，我们可以把这5个测试用例的名字写在gtf.conf 配置文件中。 runner manage类的功能就是读取gtf.conf中的测试用例名，与全局的list进行匹配。如果成功，就执行这个用例；如果失败，就跳过。4. 提供了大量的比较宏： mt_assert/ mt_check5. 结果保存的方式有三种；*.log 是实时log文件； *.csv 是统计后的文件；console是实时输出在终端的log，与*.log的内容一样。6. 提供了写测试用例的宏： test_suite/ test_case7. 增加了死亡测试： 核心功能是所有测试用例都是运行在一个新的进程里面，而不是一个线程里面。 这样，如果其中一个测试用例导致进程异常退出，仅仅只是这个进程退出，不影响别的进程，也就是说别的测试用例依然可以正常运行。函数平台对比；           window           linux头文件     windows.h        unistd.h时间函数   sleep/getlocaltime     gettimeofday/ sleep管道       createpipe            pipe进程       createprocess         fork2008.8-2010.2 foxconn手机嵌入式app开发2008年毕业参加工作，在foxconn参与了 手机嵌入式app开发工作，今天总结下：硬件： 手机嵌入式平台： window mobile 6.1图形绘制引擎： edgelib场景： 短信及拨号界面开发开发的ui界面如下: 图1-1 图1-2 图1-3可以看到ui是有很多widget组成的（例如： button，gridlist ，text 等）. 这些widget默认是hide的，只有在需要的时候被show出来。拿短信这个app来说，它被设计成一个form。 这个form（它也是widget manager的特殊子类，widget manager是widget的子类），有很多widget manager组成， widget manager又有widget组成，结构如下：这些widget/widget manager/ form都继承自 widget这个基类。 widget里面定义了 handleevent(), display() 和 widget_id变量。 form里面采用组合模式，widgetmanager里面也采用了组合模式。 系统每个一段时间调用form::display()函数， form::display()会遍历调用所有widget的display（）方法（这些widget默认是hide的，只有在需要的时候被show出来）。我在这个项目中，主要干了两件事情：第一件事情： 消息转换 手指点击屏幕，只能产生原始的 msg_style_up/ down / move 事件及当前点击点相对于屏幕左上角的x,y坐标，我需要把这些原始事件转化为widget可识别的事件（例如：点击，长按，滑动等）。 那么如何做到了？ 在创建每一个widget的时候，都会给出（top， left， width， height）坐标， 这样才能绘制出这个widget。 有了点击点的x,y坐标,又有了所有widget的区间坐标范围，当然就可以确定是哪个widget被操作了， 然后调用 widget::handleevent()响应这个操作。网络查看windows的消息机制，介绍如下：a. 鼠标点击，产生单击事件，鼠标设备驱动程序根据用户事件，转换成消息，并放置于windows的系统队列中b. windows将系统队列中的消息取出，并投掷于消息对应的应用程序所属的线程队列。c. 每个应用程序在创建时，系统都会为其创建一个消息队列，发送给应用程序的消息都存放在该消息队列中，等待被处理。 而应用程序的消息引擎1234567会不停的从自己的专属消息队列中获取消息，并进行消息的翻译和转发（translatemessage和diapatchmessage）windows的消息机制，是知道鼠标点击在哪个控件上面的。 它怎么知道？ 也是用的点击坐标是不是在某个控件的区域坐标范围内。 我们把window后台做的事情，实现了。第二件事情： 使用状态机模式还是拿短信app来说，它有这样几个界面： 上面图1-2的界面， 写短信的界面， 及刚打开短信app，出现短信list的界面，setting界面。 我们把每个节目设置成一个状态，用状态机来简化代码逻辑。

D0160320针对MySQL提高百万条数据的查询速度优化1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。2.应尽量避免在 where 子句中对字段进行 null 判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认0，确保表中num列没有null，然后这样查询：select id from t where num=03.应尽量避免在 where 子句中使用!=或操作符，否则数据库引擎将放弃使用索引而进行全表扫描。4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以用下面这样的查询代替上面的 or 查询：select id from t where num=10union allselect id from t where num=205.in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3)对于连续的数，能用 between 就不要用 in 了：select id from t where num between 1 and 36.下面的查询也将导致全表扫描：select id from t where name like '%abc%'若要提高效率，可以考虑全文检索。7.如果在 where 子句中使用参数，也会导致全表扫描。因为sql只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*29.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)='abc'–name以abc开头的idselect id from t where datediff(day,createdate,'2005-11-30')=0–‘2005-11-30’生成的id应改为:select id from t where name like 'abc%'select id from t where createdate='2005-11-30' and createdate'2005-12-1'10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。12.不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：create table #t(…)13.很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)14.并不是所有索引对查询都有效，sql是根据表中数据来进行查询优化的，当索引列有大量数据重复时，sql查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。17.尽量使用数字型字段，若只含数信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。19.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。21.避免频繁创建和删除临时表，以减少系统表资源的消耗。22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。27.与临时表一样，游标并不是不可使用。对小型数据集使用 fast_forward 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。28.在所有的存储过程和触发器的开始处设置 set nocount on ，在结束时设置 set nocount off 。无需在执行存储过程和触发器的每个语句后向客户端发送 done_in_proc 消息。

D0856523[Hive]Hive多分区操作业务背景mobile_log记录移动日志，现在需要将其保存到hive表中，将来可以按日期，小时进行统计，为此，需要建立一张具有日期、小时的hive分区表。业务实现hive分区表分为单分区表和多分区表，一个表可以拥有多个分区，每个分区都以文件夹的形式单独存放在表的文件目录下，详细可以参见建立多分区表代码导入数据到多分区表中，实现方式有如下这些：建表的时候，就插入数据，参考：使用方式导入数据，参考新增分区时导入数据，参考：实验结果表结构表分区

D0312826每天一个linux命令（34）：du 命令linuxdu命令也是查看使用空间的，但是与df命令不同的是linuxdu命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的.df，即disk free，可用来查看当前系统的挂载情况，也可以用来查看整体磁盘的使用情况；而du命令用于显示某目录下各子目录或文件所占用的磁盘空间，默认是显示当前目录。（）du是以文件名、目录名为依据计算空间使用的，而df是以硬盘块使用情况来计算空间使用的。（：异常情况下的示例说明：是因为文件已经被mv或rm，所以文件名已经没有了，但是根据其中的介绍应用程序可以通过句柄直接写磁盘，所以在计算时du是不计算这部分空间的，但df是要计算这部分空间的，所以造成二者很大的差距。）1．命令式：du[选项][文件]2．命令功能：显示每个文件和目录的磁盘使用空间。3．命令参数：-a或-all显示目录中个别文件的大小。-b或-bytes显示目录或文件大小时，以byte为单位。-c或--total除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-k或--kilobytes以kb(1024bytes)为单位输出。-m或--megabytes以mb为单位输出。-s或--summarize仅显示总计，只列出最后加总的。-h或--human-readable以k，m，g为单位，提高信息的可读性。-x或--one-file-xystem以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-l符号链接或--dereference符号链接显示选项中所指定符号链接的源文件大小。-s或--separate-dirs显示个别目录的大小时，并不含其子目录的大小。-x文件或--exclude-from=文件在文件指定目录或文件。--exclude=目录或文件略过指定的目录或文件。-d或--dereference-args显示指定符号链接的源文件大小。-h或--si与-h参数相同，但是k，m，g是以1000为换算单位。-l或--count-links重复计算硬件链接的文件。4．使用实例：实例1：显示目录或者文件所占空间命令：du输出：[root@localhosttest]#du608./test6308./test44./scf/lib4./scf/service/deploy/product4./scf/service/deploy/info12./scf/service/deploy16./scf/service4./scf/doc4./scf/bin32./scf8./test31288.[root@localhosttest]#说明：只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小实例2：显示指定文件所占空间命令：dulog2012.log输出：[root@localhosttest]#dulog2012.log300log2012.log[root@localhosttest]#说明：实例3：查看指定目录的所占空间命令：duscf输出：[root@localhosttest]#duscf4scf/lib4scf/service/deploy/product4scf/service/deploy/info12scf/service/deploy16scf/service4scf/doc4scf/bin32scf[root@localhosttest]#说明：实例4：显示多个文件所占空间命令：dulog30.tar.gzlog31.tar.gz输出：[root@localhosttest]#dulog30.tar.gzlog31.tar.gz4log30.tar.gz4log31.tar.gz[root@localhosttest]#说明：实例5：只显示总和的大小命令：du-s输出：[root@localhosttest]#du-s1288.[root@localhosttest]#du-sscf32scf[root@localhosttest]#cd..[root@localhostsoft]#du-stest1288test[root@localhostsoft]#说明：实例6：方便阅读的式显示命令：du-htest输出：[root@localhostsoft]#du-htest608ktest/test6308ktest/test44.0ktest/scf/lib4.0ktest/scf/service/deploy/product4.0ktest/scf/service/deploy/info12ktest/scf/service/deploy16ktest/scf/service4.0ktest/scf/doc4.0ktest/scf/bin32ktest/scf8.0ktest/test31.3mtest[root@localhostsoft]#说明：实例7：文件和目录都显示命令：输出：[root@localhostsoft]#du-ahtest4.0ktest/log31.tar.gz4.0ktest/test13.tar.gz0test/linklog.log0test/test6/log2014.log300ktest/test6/linklog.log0test/test6/log2015.log4.0ktest/test6/log2013.log300ktest/test6/log2012.log0test/test6/log2017.log0test/test6/log2016.log608ktest/test60test/log2015.log0test/test4/log2014.log4.0ktest/test4/log2013.log300ktest/test4/log2012.log308ktest/test44.0ktest/scf/lib4.0ktest/scf/service/deploy/product4.0ktest/scf/service/deploy/info12ktest/scf/service/deploy16ktest/scf/service4.0ktest/scf/doc4.0ktest/scf/bin32ktest/scf4.0ktest/log2013.log300ktest/log2012.log0test/log2017.log0test/log2016.log4.0ktest/log30.tar.gz4.0ktest/log.tar.bz24.0ktest/log.tar.gz0test/test3/log2014.log4.0ktest/test3/log2013.log8.0ktest/test34.0ktest/scf.tar.gz1.3mtest[root@localhostsoft]#说明：实例8：显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和命令：du-clog30.tar.gzlog31.tar.gz输出：[root@localhosttest]#du-clog30.tar.gzlog31.tar.gz4log30.tar.gz4log31.tar.gz8总计[root@localhosttest]#说明：加上-c选项后，du不仅显示两个目录各自占用磁盘空间的大小，还在最后一行统计它们的总和。实例9：按照空间大小排序命令：du|sort-nr|more输出：[root@localhosttest]#du|sort-nr|more1288.608./test6308./test432./scf16./scf/service12./scf/service/deploy8./test34./scf/service/deploy/product4./scf/service/deploy/info4./scf/lib4./scf/doc4./scf/bin[root@localhosttest]#说明：实例10：输出当前目录下各个子目录所使用的空间命令：du-h--max-depth=1输出：[root@localhosttest]#du-h--max-depth=1608k./test6308k./test432k./scf8.0k./test31.3m.[root@localhosttest]#说明：注：可以看到单独的du会显示子目录和当前目录的大小；du -a会显示所有目录、子目录和其中的文件；du -s只会显示当前目录的总大小；来源：参考：（豆瓣介绍，设计df、du的介绍和对于du输出按大小排序排序）

D0607248struts文件上传，获取文件名和文件类型action中还有两个属性：uploadfilename和uploadcontenttype，这两个属性分别用于封装上传文件的文件名、文件类型。这是struts2设计的独到之处：strut2的action类直接通过file类型属性直接封装了上传文件的文件内容，但这个file属性无法获取上传文件的文件名和文件类型，所以struts2就直接将文件域中包含的上传文件名和文件类型的信息封装到uploadfilename和 uploadcontenttype属性中，也就是说struts2针对表单中名为xxx的文件域，在对应的action类中使用3个属性来封装该文件域信息：l 类型为file的xxx属性：用来封装页面文件域对应的文件内容。l 类型为string的xxxfilename属性：用来封装该文件域对应的文件的文件名。l 类型为string的xxxcontenttype属性：用来封装该文件域应用的文件的文件类型。以下是实际java代码：jsp页面：input type=file id=upload name=upload/ 这个name就是与action的属性对应action类代码：  private file upload;  private string uploadfilename;  private string uploadcontenttype;  public void setupload(file upload) {    this.upload = upload;  }   public void setuploadfilename(string uploadfilename) {    this.uploadfilename = uploadfilename;  }  public void setuploadcontenttype(string uploadcontenttype) {    this.uploadcontenttype = uploadcontenttype;  }设置3个属性。分别给set方法. 这样子，就能够获取上传的文件，文件名，文件类型。注意：这个uploadfilename，uploadcontenttype。如果file 属性名xxx(private file xxx;) 。那这个必须是xxxfilename, xxxcontenttype。然后也是分别给set 方法就可以。特别注意：，s:file/标志不仅仅是绑定到upload，还有uploadcontenttype（上传文件的mime类型）和uploadfilename（上传文件的文件名，该文件名不包括文件的路径）。因此，s:file name=xxx /对应action类里面的xxx、xxxcontenttype和xxxfilename三个属性。

D0531242快速实现自定义应用字体现在手机上字体美化软件越来越多,各种怪状各种风的字体都有,作为android开发人员,应用中有时会需要强制使用某种字体(这样做会增大应用的内存消耗,而且字体包越大消耗内存越大),所以我们就需要尽量的减少内存消耗,同时使用我们自定义的字体设置自定义字体的方法在xml中,可以看到一个属性：不过在xml中只能设置为none,sans,serif,monospace中的一种在java代码中,可以找到textview的一个方法我们通过textview.settypeface(typeface);即可实现自定义字体,typeface对象我们可以typeface类的createfromasset静态方法创建(这里是不是就是前面所学的工厂模式呢),总之,实现起来跟简单。但是不能每次都这样重新获取textview再重新设置字体吧,这样太麻烦,而且消耗性能,所以我们就可以自定义textview,然后重写ondraw：布局文件（很简单，就是包含3个自定义textview）：然后运行起来,一看占内存情况,惊呆了,使用了3个我们自定义的textview,这里主要的原因就是我们每次使用该控件就调用了typeface.createfromasset(getresources().getassets(), “fzltxh_gbk.ttf”),产生typeface对象十分耗内存,这里我们可以把typeface设计成单例模式,这样可以减少内存消耗，使用字体包较小的字体文件也能大大减少内存消耗。下面介绍一个开源库calligraphy,很方便的进行字体更换,github地址:使用:1.引用库,在assets/fonts/ 下放入需要的字体2.在你的应用的application类中的oncreate方法中初始化3.在你的activity中重写 attachbasecontext方法运行起来会看到应用中实现了自定义字体,快试试吧。

D0452021第一章节 android起航                                    啄米科技   自己准备把知识梳理一遍，顺便将代码敲一遍。也为了督促自己好好学习。从今天开始，每天都得写日记。并且将知识点以附件的形式上传。以第一行代码这本书为蓝本开始学习。前期可能非常慢，后期会越来越快。如果前期太快，后期还得重来。这个仅作为自己复习使用。   adt 。刚开始先用adt，熟练掌握后，在基础知识学完后，用studio。首先 ：sdk版本不要经常更新，因为sdk只能往高的升，不能降，有时候sdk版本太高adt版本太低，容易出问题。关于版本更新 可以用镜像。启动 android sdk manager ，打开主界面，依次选择「tools」、「options...」，弹出『android sdk manager - settings』窗口；在『android sdk manager - settings』窗口中，在「http proxy server」和「http proxy port」输入框内填入mirrors.neusoft.edu.cn和80，并且选中「force https://... sources to be fetched using http://...」复选框。设置完成后单击「close」按钮关闭『android sdk manager - settings』窗口返回到主界面；依次选择「packages」、「reload」。低版本可以在高版本上运行，所以尽量选择低版本吧不是所有的用户都是高版本 。缺点就是没法用最新的api。开发的时候尽量选择小的sdk，因为要照顾到所有的手机。尽量不要在版本上花费太多时间。更新的话，tools下别更新。api15以上。关于适配：只适配 的 4.0.3到4.0.4 以上的版本，ice cream sandwich。从api 15开始。关于arm mips x86 system image 镜像文件，是为了支持不同cpu的手机。在本地可以模拟使用。 实际操作中只用到genymotion ，因为速度快。 自己的手机也行，只是要经常看手机。adt自带的非常慢。垃圾。苹果电脑的电脑采用的是x86架构 。手机是自己的a9架构。  开始第一个demo。创建一个基于master/detail flow 模版的appsrc下 2个activity 2个framelayout  1个实体类。布局文件为3个activity布局 。1个fragmen布局t。因为有1个activity继承listfragment。xmlns:tools=这个是xml的命名空间,有了他,你就可以alt/作为提示,提示你输入什么,不该输入什么,什么是对的,什么是错的,也可以理解为语法文件。或者语法判断器tools:layout=@android:layout/list_contenttools:layout仅仅是告诉编辑器，fragment在程序预览的时候该显示成什么样，并不会对apk产生实际作用，是为开发者设计的推荐大家一个android镜像网：源码下载：

D0128634Android_webview与js的交互方式一：hybird app, web app 和 native app 的区别native app是一种基于智能手机本地操作系统如ios，android等并运用原生程序编写运行的第三方运用程序，也叫本地app。web app 是针对iphone，android优化后的web站点，前端使用的技术是：html或者html5，css3，javascript等，服务器端技术是java，php，asp等。需要注意的是web app开发还是比较有限的。因为web app开发不能整合设备的核心功能，比如发文本信息，也不能充分使用app store进行更新。但是web app开发也有其优势所在。  首先它解决了iphone app的可扩展性问题，因为它是可以跨平台使用的。比如你开发了一款web app，那么它既可以在手机iphone上使用，也可以再平板ipad上使用，而不像iphone app那样只针对某个平台。  其次web app也绕开了appstore严的提交和更新审查规则。众所周知，随着app store中的app逐渐增多，app store也推出了一系列的提交和审查规则，可谓相当之严。而web app则绕开了这些提交和更新审查规则，从而使得web app的升级和维护变得更容易。因为它是一个独立的站点，而不是依附于app store上的，不管是升级还是维护在客户端进行即可，无需提交审核。hybird app通常分为三种类型：多view混合型，单view混合型，web主体型。多view混合型：即native view和web view独立展现，交替出现。目前常见的hybird app是native view与web view交替出现，这种应用混合逻辑相对简单，即在需要的时候，将webview当成一个独立的view(activity)运行起来，在webview内完成相关的展示操作。这种移动运用主体通常是 native app, web技术只起到补充作用。开发难度和native app相当。单view混合型：即在同一个view内，同时包括native view和web view。互相之间是覆盖（层叠）的关系。这种hybrid app的开发成本较高，开发难度较大，但是体验较好。如百度搜索为代表的单view混合型移动应用，既可以实现充分的灵活性，又能实现较好的用户体验。web主体型：即移动应用的主体是web view，主要以网页语言编写，穿插native功能的hybrid app开发类型。这种类型开发的移动应用体验相对而言存在缺陷，但整体开发难度大幅降低，并且基本可以实现跨平台。web主体型的移动应用用户体验的好坏，主要取决于底层中间件的交互与跨平台的能力。国外的appmobi、phonegap，国内的appcan和rexsee都属于web主体型移动应用中间件。其中rexsee不支持跨平台开发。appmobi和phonegap除基础的底层能力更多是通过插件（plugins）扩展的机制实现hybrid。而appcan除了插件机制，还提供了大量的单view混合型的接口来完善和弥补web主体型hybrid app体验差的问题，接近native app的体验。从分析可见，hybrid app中的web主体型只要能够解决用户体验差的问题，就可以变成最佳hybrid app解决方案类型。二：android_webview与js的交互方式关于webview。我们知道目前android市场上的一些应用采用的开发方式分为三种：native app，web app，hybird app 。下面介绍hybird app中实现的主要技术native组件与js的数据交互的理解。android api中提供了webview组件来实现对html渲染，所谓的hybridapp开发方式即是汇集了html5、css3、js的相关开发技术，以及数据交换式json/xml。 下面是android_webview 与 js交互的步骤如下：1.新建一个webview的布局webview.xml?xml version=1.0encoding=utf-8?linearlayoutxmlns:android=  android:layout_width=match_parent  android:layout_height=match_parent  android:orientation=vertical   webview    android:id=@id/webview    android:layout_width=match_parent    android:layout_height=match_parent//linearlayout如果应用中需要用到多个webview的界面，那只要写一个布局就够了。2. 在activity中初始化webview初始化布局setcontentview(r.layout.exam);webview = (webview) findviewbyid(r.id.webview);    webview.setscrollbarstyle(0);//滚动条风，为0指滚动条不占用空间，直接覆盖在网页上添加设置，使js代码能运行websettings setting = webview.getsettings();setting.setjavascriptenabled(true);setting.setjavascriptcanopenwindowsautomatically(true);setting.setallowfileaccess(true);//设置允许访问文件数据setting.setsupportzoom(true);setting.setbuiltinzoomcontrols(true);setting.setjavascriptcanopenwindowsautomatically(true);setting.setcachemode(websettings.load_cache_else_network);setting.setdomstorageenabled(true);setting.setdatabaseenabled(true);setting.setdefaulttextencodingname(gbk);//设置字符编码webview.addjavascriptinterface(new androidforjs(this),javascriptinterface);部分设置的作用目前还不清楚，但最好都加上。设置完这些后会发现在调试js代码时还是不能弹出alert对话框调式代码，上网查了之后发现是要添加如下代码：webview.setwebchromeclient(new webchromeclient());装载html5页面本地界面：webview.loadurl(file:///android_asset/test.html);，其中test.html页面是放在assets文件夹下。在线界面：webview.loadurl();3.具体的交互如下：（1）js调用native代码上面的代码中webview.addjavascriptinterface(new androidforjs(this),javascriptinterface);其中androidforjs就是专门用来放js调用native的代码的，javascriptinterface就是js调用androidforjs时的名称，先写一个androidforjs.java代码如下public class androidforjs { private contextmcontext; private stringcmdcode, resultkey; privatelong visittime;public androidforjs(context context) {this.mcontext = context;}// 以json实现webview与js之间的数据交互public string jsontohtml(string abc) {jsonobject map;jsonarray array = new jsonarray();try {map = new jsonobject();map.put(name, abc);map.put(age, 25);map.put(address, abc);array.put(map);map = new jsonobject();map.put(name,jacky);map.put(age, 22);map.put(address,中国北京);array.put(map);map = new jsonobject();map.put(name,vans);map.put(age, 26);map.put(address,中国深圳);map.put(phone,13888888888);array.put(map);} catch (jsonexception e) {e.printstacktrace();}return array.tostring();}}上面的都是android(java)方法的配置项，前端不需要做任何事情。下面如下方法是前端调用native方法。然后在js中可以用如下方式调用native方法var result = javascriptinterface.jsontohtml(uyiyu);其中uyiyu就是js传给native的参数，需要的话就把参数传过去，不需要的话就不传。看具体的需求。其中jsontohtml是java中的一个方法。也可以改成其他的方法名。result是native方法返回的.一般是返回前端json数据，但是使用这种方式有问题，前端拿不到返回的数据，我们可以接着往下看。注意：项目中遇到的问题是如果调用的native方法如果是一个向服务器发起请求的方法，如下：public string getequipment() {string result = null;cmdcode =123;visittime = system.currenttimemillis() / 1000;resultkey = utils.getresultkey(cmdcode,visittime, mcontext);string key = utils.getkey(cmdcode,visittime, mcontext);final string url = utils.getmainurl(key,cmdcode, visittime,allserverport.url_get_equipment,mcontext);logutil.d(url);new httpgetdata(mcontext,new callback() {@overridepublicvoid handlerdata(string result) {// todo auto-generated method// stublogutil.d(-----response------  result);mapstring, string backmsg = utils.parseresponseresult(mcontext, result,cmdcode, visittime, resultkey);if (backmsg.get(constant.back_flag).equals(1)) {string body = backmsg.get(constant.back_body);jsonobject jsonbody;jsonarray jsonarray = null;try {jsonbody = new jsonobject(body);jsonarray = jsonbody.getjsonarray(dispatchkitlist);} catch (jsonexception e) {// todo auto-generated catch blocke.printstacktrace();}result = jsonarray.tostring();logutil.d(------------success--------------  jsonarray.tostring());}}}, url).start();return result;}这时如果还用var result = javascriptinterface.getequipment();这个方法会发现获取的result是null的，这是因为java中向服务器请求后到服务器返回结果进入回调函数handlerdata是需要一段时间的，而js没有等待这段时间就从java获取了返回，这时result还没被赋，就为空了，解决的方法只能是native从服务器端获取到数据后再调用js的方法把结果传给js。所以上述方法改为public string getequipment() {string result = null;cmdcode =123;visittime = system.currenttimemillis() / 1000;resultkey = utils.getresultkey(cmdcode,visittime, mcontext);string key = utils.getkey(cmdcode,visittime, mcontext);final string url = utils.getmainurl(key,cmdcode, visittime,allserverport.url_get_equipment,mcontext);logutil.d(url);new httpgetdata(mcontext,new callback() {@overridepublicvoid handlerdata(string result) {// todo auto-generated method// stublogutil.d(-----response------  result);mapstring, string backmsg = utils.parseresponseresult(mcontext, result,cmdcode, visittime, resultkey);if (backmsg.get(constant.back_flag).equals(1)) {string body = backmsg.get(constant.back_body);jsonobject jsonbody;jsonarray jsonarray = null;try {jsonbody = new jsonobject(body);jsonarray = jsonbody.getjsonarray(dispatchkitlist);} catch (jsonexception e) {// todo auto-generated catch blocke.printstacktrace();}message message = myequipmentactivity.handler.obtainmessage();message.what = constant.handler_show_equipment;message.obj = jsonarray.tostring();myequipmentactivity.handler.sendmessage(message);logutil.d(------------success--------------  jsonarray.tostring());}}}, url).start();return result;}handler中调用js方法public static handlerhandler = new handler() {@overridepublicvoid handlemessage(message msg) {// todo auto-generated method stubsuper.handlemessage(msg);string handlermsg = ;if (msg.obj !=null) {handlermsg = msg.obj.tostring();}switch (msg.what) {case constant.handler_show_equipment:webview.loadurl(javascript:getequipmentsuccess('  handlermsg '));break;default:break;}}};如上代码：webview.loadurl(javascript:getequipmentsuccess('  handlermsg '));js中调用native方法拿json数据最终方案：前端只需要如下调用即可：function getequipmentsuccess(json) {var data = eval((json));//解析json字符串// data就是我们从开发那边拿回来的json数据了。}（2）native调用js方法a．常见的方法是不带参数：webview.loadurl(javascript:submit());带参数：webview.loadurl(javascript:getlistsuccess('  handlermsg  '));目前程序中使用的方法就是这个，但是因为用这个方法无法获取js return的参数，所以需要来回互相调用才能完成一次交互，比较麻烦。b. 后来在网上查到原来native调用js还有一个方法evaluatejavascriptwebwiew.evaluatejavascript(script,newvaluecallbackstring(){@overridepublicvoidonreceivevalue(stringvalue){log.d(tag,onreceivevaluevalue=value);if(value!=null){flag_get_deviceid=true;}}});这个方法可以获取js return的方法，网上很少人提到，我还没试过，如果确实可用的话可以方便很多。（3）即上面可知：开发有2种（带参数和不带参数）方法调用前端代码，如下：不带参数：webview.loadurl(javascript:submit());带参数：webview.loadurl(javascript:getlistsuccess('  handlermsg  '));其中submit是我们javascript中的一个方法名称。如下可以这样写代码：function submit(){var result = callbackdata();javascriptinterface.submitresult(result);}callbackdata函数 是我们前端写的一个方法，意思是返回所有可用的数据给开发。使用result变量保存起来，之后使用javascriptinterface.submitresult(result)方法调用即可。submitresult是java方法，不用管！开发通过上面的代码就可以拿到我们前端的返回数据。 综合所述：js中调用native方法拿json数据最终方案：前端只需要如下调用即可：function getequipmentsuccess(json) {var data = eval((json));//解析json字符串// data就是我们从开发那边拿回来的json数据了。}服务器端需要有这个方法：webview.loadurl(javascript:getequipmentsuccess('  handlermsg '));js中的数据返回给native端。如下代码：function submit(){var result = callbackdata();javascriptinterface.submitresult(result);}服务器端 需要有这个调用方法：webview.loadurl(javascript:submit());三： js与ios native code互调方法 为大家介绍一个优秀的国人开发开源小项目：webviewjavascriptbridge。它优雅地实现了在使用uiwebview时js与ios的objective-c nativecode之间的互调，支持消息发送、接收、消息处理器的注册与调用以及设置消息处理的回调。它是连接uiwebview和javascript的bridge。 如下js代码实现connectwebviewjavascriptbridge function connectwebviewjavascriptbridge(callback) {   if (window.webviewjavascriptbridge) {     callback(webviewjavascriptbridge)   } else {     document.addeventlistener('webviewjavascriptbridgeready', function() {callback(webviewjavascriptbridge) }, false) }} connectwebviewjavascriptbridge (function(bridge) {// init方法是把数据传给开发 先使用callbackdata返回所有开发需要的数据// 再调用responsecallback(data)bridge.init(function(message, responsecallback) {     var data = callbackdata(); responsecallback(data)});  // registerhandler 这个方法是从ios拿到数据 给前端。  bridge.registerhandler('testjavascripthandler', function(data, responsecallback) { var data = eval((data));})});                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

D021374420条Linux命令面试问答			问:1 如何查看当前的linux服务器的运行级别？答:‘who -r’ 和 ‘runlevel’命令可以用来查看当前的linux服务器的运行级别。问:2 如何查看linux的默认网关？答:用 “route -n” 和 “netstat -nr”命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。问:3 如何在linux上重建初始化内存盘镜像文件？答:在centos 5.x / rhel5.x中，可以用mkinitrd命令来创建初始化内存盘文件，举例如下：如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 ‘uname -r’ 。在centos 6.x / rhel 6.x中，则用dracut命令来创建初始化内存盘文件，举例如下：以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令：问:4 cpio命令是什么？答:cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。问:5 patch命令是什么？如何使用？答:顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。举个例子，linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，然后接收者用patch命令将改动写进原始的源代码里。创建一个diff文件给patch使用，旧文件和新文件要么都是单个的文件要么都是包含文件的目录，-r参数支持目录树递归。一旦diff文件创建好，我们就能在旧的文件上打上补丁，把它变成新文件：问:6 aspell有什么用 ?答:顾名思义，aspell就是linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。问:7 如何从命令行查看域spf记录？答:我们可以用dig命令来查看域spf记录。举例如下：问:8 如何识别linux系统中指定文件(/etc/fstab)的关联包？答:以上命令能列出提供“/etc/fstab”这个文件的包。问:9 哪条命令用来查看bond0的状态？答:问:10 linux系统中的/proc文件系统有什么用？答:/proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括cpu、内存、分区划分、i/o地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。问:11 如何在/usr目录下找出大小超过10mb的文件？答:问:12 如何在/home目录下找出120天之前被修改过的文件？答:问:13 如何在/var目录下找出90天之内未被访问过的文件？答:问:14 在整个目录树下查找文件“core”，如发现则无需提示直接删除它们。答:问:15 strings命令有什么作用？答:strings命令用来提取和显示非文本文件中的文本字符串。（lctt译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处）问:16 tee 过滤器有什么作用 ?答:tee过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。在以上例子中，从ll输出可以捕获到 /tmp/ll.out 文件中，并且同样在屏幕上显示了出来。问:17 export ps1 = ”$logname@hostname:\$pwd:这条命令是在做什么？答:这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。问:18 ll | awk ‘{print $3,”owns”,$9}’ 这条命令是在做什么？答:这条ll命令会显示这些文件的文件名和它们的拥有者。问:19 :linux中的at命令有什么用？答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at目录下并且到了执行时间的时候通过atd守护进程来执行。问:20 linux中lspci命令的作用是什么？答:lspci命令用来显示你的系统上pci总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性。版权声明：本文是linux中国翻译，已按转载要求注明信息。原文：作者： pradeep kumar译文：lctt 译者： ztinoz翻译结果									

D0443420windows环境配置java和tomcat一.jdk下载:根据你的系统点击相应的版本。我的系统是64位windows，选择jdk-7u45-windows-x64下载。二.tomcat下载，你需要下载与jdk相配的版本，如apache-tomcat-8.0.0-rc5-windows-x64.exe三.安装与配置环境变量1、先安装jdk，跟你平时安装软件一样，非常傻瓜地进行着，在此就不讲述了。在这里说明一下，一般网上 复制的经验都是直接默认安装路径，本人在这里非常看不过带有版本号的文件夹，在安装选择路径的时候直接安装在c盘文件夹jdk下如下图所示。2、配置jdk环境变量这一步很多人都不明白，一般都是对着配置。简单地说，就是相当给你安装的jdk路径取个别名，方便以后在cmd命令行操作编译。1）右击计算机（我的电脑）-属性或者直接点击控制面板，将会弹出控制面板主页。2）请根据图a所示选择环境变量，将弹出图b所示的窗口4.3）在系统变量中需要新建3个变量大小写不区分，如果存在相同变量名，请使用编辑修改变量。变量名为java_home，变量为：c:\jdk（具体请根据你安装的jdk路径而定，如果是默认应该是这个形式c:\program files\java\jdk1.7）变量名为classpath，变量为.;%java_home%\lib;变量名为path，变量为%java_home%\bin至此完成了jdk的环境配置，请在cmd命令行界面下输入java -version测试是否安装成功。下面进行tomcat服务器的安装与配置5.tomcat的安装与配置解压下载文件包，不习惯版本号文件夹，在这里我修改默认文件夹名apache-tomcat-8.0.0-rc5-windows-x64为tomcat。请同学们根据自己的意愿选择。6.配置tomcat环境变量打开系统环境变量请参考第三步图示操作。在系统变量中添加以下变量1）新建tomcat_home变量变量名tomcat_home变量c:\tomcat变量即为我们下载的tomcat解压路径，在这里我的是c:\tomcat，如果有疑惑，可以参考第五步。7.2)新建catalina_home变量变量名catalina_home变量c:\tomcat没错，catalina_home的变量与tomcat_home的变量是一样的。8.3）修改变量path在系统变量中找到path变量名，双击或点击编辑，在末尾添加如下内容;%catalina_home%\bin;%catalina_home%\lib这里要注意，各个变量之间一定要用;分隔。9.）启动tomcat服务器在cmd命令窗口下输入startup回车，运行如下图所示

D0546852Perl  修改循环控制流的语句标记修饰符标记有自己的命名空间，和标量变量、列表、hash、函数一样，不过由于它没有特别的前置符号，所以在命名上有一些限制：如尽量不要和其他的命名冲突，标记名称最好由大写字母和数字构成，这样保证不会和任何保留字冲突，而且看起来也比较明显。选定标记之后，只要把它放在需要的语句前面，并加上冒号即可，下面是此用法的一个示例：last语句使用不带标号的修饰符的last语句时，退出当前语句块，使用带标号的修饰符的last语句时，退出与所带标号修饰符相关的语句块。示例：简单来说，last的意思是退出循环，与c语言中的break作用相同。next语句    使用不代标号修饰符的next语句时，退出本次执行的当前语句块，继续判断循环条件执行循环；使用带标号修饰符的next语句时，退出与所带标号修饰符相关联的循环，仍需要继续判断循环条件执行循环。示例：简单来说，next的含义是执行下一个循环，与c语言的continue作用相同。redo语句使用不带标号修饰符的redo语句时，语句跳到所在语句块的第一条语句上；使用带标号修饰符的read语句时，跳到与所带标号相关联的语句块上的第一条语句上。示例：redo是perl的一个特有命令，其含义是重复此次循环，即循环变量不变，回到循环起始点。但要注意，redo命令在do循环中不起作用。

D0785743iOS 开启僵尸调试模式1、为什么会使用nszombieenabled？应用调试可能会收到类 thread1: program received signal:exc_bad_access 这样的错误提示信息，这样的信息通常是内存操作错误引起，例如你对已释放的对象发送消息时就会出现，再如release的对象再release，release那些autorelease的对象等当设置nszombieenabled环境变量后，一个对象销毁时会被转化为_nszombie，设置nszombieenabled后，当你向一个已经释放的对象发送消息，这个对象就不会向之前那样crash或者产生一个难以理解的行为，而是放出一个错误消息，然后以一种可预测的可以产生debug断点的方式消失， 因此我们就可以找到具体或者大概是哪个对象被错误的释放了。2、如何设置为nszombieenabled模式？方法一：product -scheme- edit scheme- arguments-environment variables-点击加号, 将 nszombieenabled 参数加到environment variables 窗口中, 后面的数写yes

D0087501Git原理杂谈之pull/push命令这边文章是基于之前三篇文章的后续篇，之前三篇能够帮助小白同学概要性地理解git的整体原理及快速掌握git基本技能以进入团队开发，所以建议对git只了解些浅层内容的看客老爷们先看完前三篇再从本篇开始往后看。因为从本篇开始，小编将会挑一些细节内容给大家进行解析，这些细节内容是建立在读者已经掌握了整体原理的基础上的。好了废话不多说了，直接进入今天的主题——git push/ git pull命令。也许很多人会轻视这两个最常见且高频使用的命令，这有什么可讲的？没错，如果项目没有出问题的情况下，我们大可不必关心这两个命令的原理及涉及到的所有细节，直接使它们喽~但是一旦项目出了什么小问题，使项目管理稍微脱离了“正常”流程，如果不了解这两个命令的话，大部分都容易傻。续之前几篇的风，小编先从偏表层讲清楚一些原理，等消化后再进一步讲解内部的细节原理。（ps：了解了各层次的原理后才能遇到问题都能理智地分析并解决掉问题）upstream：这个概念虽然不官方，但也非纯粹小编自造，希望大家首先了解一下。心存感激，如果当我们上来就能够顺利使用git push（git pull同理，后文尽量只拿一个来讲）命令就能实现推送数据到服务器上的时候，我们是幸运的。因为有幸在一些底层的未知设置下我们才能够简单地使用git push命令。其实，如果稍微写全面一点的话，很有可能我们的命令是像这样的：git push origin master。origin是远程端代名词（前几篇有讲解），master是这个远程端的一个分支名。所以这句命令的意思可以理解成“推送我的数据到origin端的master分支上去”。为什么很多时候，我们根本没有写这么全，也能够实现呢？而且刚才的解释也没有说明：把什么数据哪里的数据推送上去？ 所以通过这些问题的引入，希望读者们能够开始进行思考问题并去了解其内在的原理。这里可以引入一个upstream的概念。可以将upstream理解成一个通道，它用于连接你本地的一个分支和远程的某个分支。比如远程库a上有3个分支branch1、branch2、branch3。远程库b上有3个分支branchx、branchy、branchz。本地仓库有2个分支local1和local2。那么当初始状态时，local1和local2和任何一个分支都没有关联，也就是没有upstream。当通过git branch --set-upstream-to=a/branch1 local1命令执行后，会给local1和branch1两个分支建立关联，也就是说local1的upstream指向的是branch1。这样的好处就是在local1分支上执行git push（git pull同理）操作时不用附加其它参数，git就会自动将local1分支上的内容push到branch1上去。同样，local2分支也可以和远程库a和远程库b上的任何一个分支建立关联，只要给local2分支设置了upstream，就可以在local2分支上用git push（git pull同理）方便地与目标分支推拉数据。综上所述，upstream与有几个远程库没有关系，它是分支与分支之间的流通道。再来说说git push -u和git branch --set-upstream-to=指令之间的区别。举个例子：我要把本地分支master与远程仓库origin里的分支gaga建立关联。（如果使用下列途径1的话，首先，你要切换到master分支上（git checkout master））两个途径：1. git push -u origin gaga 2. git branch --set-upstream-to=origin/gaga master这两种方式都可以达到目的。但是1方法更通用，因为你的远程库有可能并没有gaga分支，这种情况下你用2方法就不可行，连目标分支都不存在，怎么进行关联呢？所以可以总结一下：git push -u origin gaga 相当于 git push origin gaga  git branch --set-upstream-to=origin/gaga master讲到这里，希望大家在使用简单的git push命令时，心里要有个upstream的概念，而且一旦遇到了本地分支没有设置upstream时可以一看出并顺利解决。番外篇：来说说一个比较关键的题外话git config --global push.default simple命令。因为这个命令是在电脑上安装完后小编建议大家就须要设置的一个指令这句命令的意思是“把push命令的全局默认模式设置成：simple”。当然，你也可以设置成其它模式（如：matching），当然小编不建议，后文详解。由此可以联想到也可以git config --global pull.default simple来给pull动作也设置一下，后文就不再点出。simple模式：说白了就是从哪里来到哪里去。一个简单的例子就会明白：如果我的本地分支brancha是从origin端的brancha分支上pull下来的，那么在simple模式下，以后我再站在brancha这个本地分支上执行git push命令时，git就会自动把我本地brancha上更新的内容推到origin端的brancha分支上去。现在就不难推断，为什么有时候，我们什么都没设置，上来就用git push就能够达到目的而没有被老大骂？因为你的git版本的默认push.default是simple模式，而且在你来入职的时候，公司远程服务器上已经为你准备好了属于你的分支brancha，而当你把公司远程库给clone下来的时候，因为simple的模式设置，当你切(checkout)到你本地的brancha分支时，git就已经知道你本地的这个brancha分支来自何方，而且它也知道该把你的数据推向何方了(这里读者可以把upstream的概念思考进来，就能够明白其实git是通过设置upstream来实现simple这个模式的功能的)。这样就会导致很多用户上来就可以无脑地使用git pull和git push了。matching模式：这个模式小编了解不是特别特别详细，可能就是通过分支名称进行匹配。举个例子，如果你的远程分支上有两个分支：branch1和branch2。你的本地分支上有三个分支branch1和branch2和branch3。那么再matching模式下，不管你站在哪个分支上执行git push时，git都会寻找本地与远程分支名称相同的分支并且全部进行推送数据。所以小编觉得这个模式很危险，不建议大家使用。可见，还是simple模式比较实用，站在哪个分支上就操作哪个分支，不会出乱子。================================================================================================================上面的浅层操作与原理理解后，相信已经可以解决很大部分读者的疑惑了，下面开始讲解一下内在的一些原理，以便对以后要讲的原理做铺垫。相信如果问git pull = git fetch  git merge 对不对？很多人都会说没错呀！其实没错当然是没错。也许你会知道，git fetch是获取服务器上的数据，git merge是将数据合并，所以git pull就是获取数据加合并数据的意思。那么：fetch的是什么数据？fetch后的数据在哪里？如果不执行git merge它们是不是丢了？git merge 是谁跟谁合并？为减少篇幅，下面以simple模式下并且只有一个远程库的情景进行分析。举个例子：你公司的服务器上有一个分支名字是feature（以后标识成feature(r)），你在clone到本地的库的本地feature(以后标识成feature(l))分支上开发。那么如果在你clone之前远程就有feature(r)的话那么你在本地的feature(l)上开发时使用git push命令就会“自动”将feature(l)的改动推送到feature(r)上。外层原理上文已经说过了，就是stream的理论。但是实际上运作原理却很微妙。不妨执行以下git branch -a命令。这个命令的含义是展示所有的分支。譬如类于下图的情况：可以看到三类分支名称：1.上半部分的白色分支：这部分分支就是本地分支，上述的feature(l)就属于这类分支；（主意绿色的dev_0430左边的*号代表我当前head所处的分支，即目前切换到的分支）2.下半部分的以remotes开头的红色分支：指向远程分支的指针（为了便于理解，就把它们当成远程分支的内容在本地的临时复制品）。这是一个十分重要的概念，后文详述。3.远程分支：即上图红色分支第一行右边的白色分支名：origin/develop。 这个就代表的远程服务器上的分支，上文提到的feature(r)就属于这个概念。这样理解的话，目前认知的就有三种类型的分支了，feature(l) feature(r)还有以remotes开头的分支（如：remotes/origin/feature，后文简称为feature(t)）。其实feature(l)和feature(r)从技术实现上根本没有任何交集，它们之间的关联全是通过feature(t)这个桥梁实现的。其实在feature(l)上执行了git fetch命令后，git会把feature(r)上的改动下载到本地更新到feature(t)分支上，如果此后不执行git merge的话，那么你的feature(l)和feature(t)就会存在差异，只有执行了git merge命令后才会把feature(t)中的内容合并到feature(l)中。现在清楚了吧？git与远程仓库之间的交互是通过这个feature(t)进行过渡的。git push也是如此，在simple模式下，我们feature(l)分支的upstream其实指向的就是feature(t)，而feature(t)这个指针就会指向真正的远程分支feature(r)。所以如果我们的feature(l)有了改动，执行git push的话，git会先把改动更新到feature(t)中，然后再讲feature(t)的改动推向远程的feature(r)中。由此才可以理解成：feature(t)就是feature(r)在本地的一个镜像。=============================================================================================================好了，关于git push/git pull背后的分支的概念现在已经说的差不多了。这是以后讲解其它原理的基础，所以一定要放在前面说下，以后的文章里会更深入地讲解一些关键的原理，以帮助大家更加灵活地运用git及解决问题。

D0435629OC特有语法总结分类 问题1.什么是分类? 就是把一个类的功能,分出一部分来放在一个独立的文件中2.分类的语法是什么样的?@interface person(superman)3.分类与类是什么关系? 分类依赖类而存在,没有类也就没有分类4.分类有什么作用?用于把一个比较庞大的类,分割开来,具有相同功能的方法放到一个分类中把太多的功能封装到一个类中,导致类文件过于庞大5.分类中能够像类一样声明成员变量?不能,分类中不能够定义成员变量1.难以维护2.难以使用6.分类中能否访问原类中的成员变量?7.分类中能够使用self关键字吗?不能8.分类中如果定义了与原类中相同的方法会调用谁?分类中的方法会被完全覆盖掉9.在实际的开发中如何应用分类?//***********************block 问题1.什么是block?block用来保存一段代码2.数据类型都有那些共同的特点?3.block的作用是什么 主要用于封装有多种解决方案，或者可以用不同算法解决的问题4.如何定义block?int (^sumblock)(int, int);void (^myblock)();5.如何调用block代码块?5.1如何利用block封装代码^(int a, int b) { return a - b;};^() { nslog(@----------);};^ { nslog(@----------);};6.block中能够访问,变量吗?1block内部可以访问外面的变量2默认情况下，block内部不能修改外面的局部变量3给局部变量加上__block关键字，这个局部变量就可以在block内部修改7.利用typedef定义block类型typedef int (^myblock)(int, int);// 以后就可以利用myblock这种类型来定义block变量myblock block;myblock b1, b2;b1 = ^(int a, int b) { return a - b;};myblock b3 = ^(int a, int b) { return a - b;};8.block跟函数很像：1可以保存代码2有返回3有形参4调用方式一样//******************protocol 问题1.什么是协议?声明一些方法,协议本身2.类如何遵守协议?3.一个类可以遵守多个协议吗?4.协议中nsobject是什么意思?5.子类继承了父类,那么子类会遵守父类中遵守的协议吗?6.协议中能偶定义成员变量?7.协议可以在类的声明文件中.h文件中定义吗?8.如何约束一个对象类型的变量要存储的地址是遵守一个协议对象?sel 问题1.什么是sel?2.如何声明一个sel?3.通过那些方法能够,调用sel包装起来的方法?单利 模式问题1.什么是单利模式?2.单利的作用是什么?3.什么时候用单利模式?

D0332349微信公众平台开发- 获取用户基本信息转自：在本文中，特别要注意的是有两个不同的access token，他们产生的方式不一样，一种是使用appid和appsecret获取的access_token，一种是oauth2.0授权中产生的access_token，方倍工作室分别称为全局access token和授权access token。一、通过全局access token获取用户基本信息1. 用户关注以及回复消息的时候，均可以获得用户的openid其中的fromusername就是openid2. 然后使用access_token接口，请求获得全局access token返回结果：3. 再使用全局access_token获取openid的详细信息返回如下：至此，获得用户的基本信息。这种方式最适合用户在关注的时候，回复一条欢迎关注用户昵称的信息，如关注下面公众账号时的回复所示。扫描二维码可体验。二、通过oauth2.0方式弹出授权页面获得用户基本信息1. 首先配置回调域名2. 构造请求url如下：页面url中的将该链接回复给关注用户，用户点击后，弹出应用授权界面3. 回调页面得到链接如下，回调url中将包含参数code4. 再使用code换取oauth2的授权access_tokenurl如下：获得授权access token:5. 再使用授权access token获取用户信息url如下：返回如下获取用户信息完成。最终得到用户信息如下所示此方法详细过程可参考这种方法适合，1. 在朋友圈中获得用户的信息.2. 在网页中获得用户信息。3. 在自定义菜单中获得用户信息。需要说明的是，如果在已经有oauth2.0网页授权权限的服务号中用这种方法，会自动转换成方法三中的那样，没有“微信登录”提示框出来。可以微信扫描下面的二维码，然后回复“授权”体验这样的获取方式。三、通过oauth2.0方式不弹出授权页面获得用户基本信息1. 配置回调域名2. 构造请求url如下：页面url中的3. 返回回调页面如下这里获得到了code4. 再使用code获取openidurl如下：返回如下5. 然后获取全局access token【以下与方法一中相同】返回结果：6. 再使用全局access_token获取openid的详细信息返回如下：成功获得用户基本信息。这种适合已经有oauth2.0网页授权的服务号在网页中使用，且不会弹出“微信登录”页面。减少给用户的打扰。四、使用哪种方法最合适供参考1. 服务号有高级接口权限：　　消息回复中三种都可以　　 自定义菜单中使用方法三 (招商银行信用卡中心使用方法三，康盛微社区使用方法二)没有高级接口权限：　消息回复中使用方法二 　　自定义菜单中使用方法二 (没有高级权限需要借用别人的appid和appsecret)2. 订阅号已认证有获取用户信息权限 　　 消息回复中使用方法一 　　自定义菜单中使用方法二 　　 (没有高级权限需要借用别人的appid和appsecret)未认证没有获取用户信息权限 　　 消息回复中使用方法二 　自定义菜单中暂无方法 　　　(没有高级权限需要借用别人的appid和appsecret，方倍工作室使用的就是这种)

D0559964JavaScript 数据类型  、JS 变量 、JS 对象javascript 数据类型 js 变量 js 对象字符串、数字、布尔、数组、对象、null、undefinedjavascript 拥有动态类型javascript 拥有动态类型。这意味着相同的变量可用作不同的类型：实例var x // x 为 undefinedvar x = 6; // x 为数字var x = bill; // x 为字符串javascript 字符串字符串是存储字符（比如 bill gates）的变量。字符串可以是引号中的任意文本。可以使用单引号或双引号：实例var carname=bill gates;var carname='bill gates';可以在字符串中使用引号，只要不匹配包围字符串的引号即可：实例var answer=nice to meet you!;var answer=he is called 'bill';var answer='he is called bill';javascript 数字javascript 只有一种数字类型。数字可以带小数点，也可以不带：实例var x1=34.00; //使用小数点来写var x2=34; //不使用小数点来写极大或极小的数字可以通过科学（指数）计数法来书写：实例var y=123e5; // 12300000var z=123e-5; // 0.00123javascript 布尔布尔（逻辑）只能有两个：true 或 false。var x=truevar y=falsejavascript 数组下面的代码创建名为 cars 的数组：var cars=new array();cars[0]=audi;cars[1]=bmw;cars[2]=volvo;或者 (condensed array):var cars=new array(audi,bmw,volvo);或者 (literal array):实例var cars=[audi,bmw,volvo];数组下标是基于零的，所以第一个项目是 [0]，第二个是 [1]，以此类推。javascript 对象对象由花括号分隔。在括号内部，对象的属性以名称和对的形式 (name : value) 来定义。属性由逗号分隔：var person={firstname:bill, lastname:gates, id:5566};上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。空和折行无关紧要。声明可横跨多行：var person={firstname : bill,lastname : gates,id : 5566};对象属性有两种寻址方式：实例name=person.lastname;name=person[lastname];undefined 和 nullundefined 这个表示变量不含有。可以通过将变量的设置为 null 来清空变量。实例cars=null;person=null;声明变量类型当声明新变量时，可以使用关键词 new 来声明其类型：var carname=new string;var x= new number;var y= new boolean;var cars= new array;var person= new object;javascript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。!-- 注意使用对象时的书写式name=person.lastname;name=person[lastname];--!doctype htmlhtmlhead title/title/headbodyscript type=text/javascript var person={  first_name : bill,  last_name : gates,  id : 7788 }; person = null;// var name_1,name_2; name_1 = person.first_name; name_2 = person.last_name; document.write(name_1  br); document.write(name_2  br);/script/body/html!doctype htmlhtmlhead title/title/headbodyscript type=text/javascript //var a = 123e10; //document.write(a); var i; var arry = new array(); arry=[audi,bmw,volvo]; for(i = 0;iarry.length;i) {  document.write(arry[i]  br); }/script/body/html

D0235990Jackson的用法实例分析通俗的来说，jackson是一个 java 用来处理 json 式数据的类库，其性能非常好。本文就来针对jackson的用法做一个较为详细的实例分析。具体如下：一、简介jackson具有比较高的序列化和反序列化效率，据测试，无论是哪种形式的转换，jackson  gson  json-lib，而且jackson的处理能力甚至高出json-lib近10倍左右，且正确性也十分高。相比之下，json-lib乎已经停止更新，最新的版本也是基于jdk15，而jackson的社区则较为活跃。下面，结合实例来对jackson的用法进行简单介绍。二、使用jackson提供了很多类和方法，而在序列化和反序列化中使用的最多的类则是objectmapper这个类，此类比较类于json-lib中jsonobject和arrayobject。此类中提供了readtree()，readvalue(),writevalueasstring()等方法用于转换。具体关于此类的说明文档地址是：。为了避免重复描述，下面中所涉及到的objectmapper均是来至于objectmapper objectmapper = new objectmapper()。下面将按照序列化和反序列化两个方面来简单介绍用法。1.序列化① 对java自带类进行序列化测试例子1234实现序列化：12在控制台输出的结果是：1结论：jackson对一般类型的序列化是能简单实现的。②对自定义类的序列化测试例子：123456789101112131415161718         为使例子更具有通用性，此类中包含了类型int，引用类型string，string[]，还包含了日期类型date。实现序列化123在控制台输出的结果是：1结论：通过输出，可见转换得到的json串是符合式的。但是，时间的表示有点不符合标准。下面将介绍对时间式的修改。③对时间式的定义jackson有自己的默认时间式，即timestamps形式，其效果即如上结果所显示的（例如：1375429228382）。如果想设置此式是无效，通过1便可设置，这样将使时间生成使用所谓的使用 [iso-8601 ]-compliant notation, 输出类如下式的时间: 1970-01-01t00:00:00.0000000。当然，也可以自定义输出的时间式。自定义时间式的实现例子还采用上面所介绍的student类。12345 控制台上输出的记过是：1结论：可见时间输出式变成了我们想要的了。在jackson中定义时间输出式的方法比在json-lib中对时间式的定义简便很多。④ 另一种序列化方法实现序列化所用例子依然是之前的student类。1234控制台上的输出结果是：1结论：此方法同样可以得到上面方法的。但是注意此方法中的这个函数：createjsongenerator（），它需要两个参数，一个是outputstream类型参数，一个是jsonencoding类型参数。通过这两个参数，我们可以了解到，此方法不仅可以将json直接写入网络流，还可以将json写入文件流或者内存流。所以用途更广。2. 反序列化①一次性反序列化此方法中主要利用objectmapper提供的testjsonclass readvalue(string content, classtestjsonclass valuetype)方法。此方法需要输入json串以及对应的需要填充的类的class，返回填充后的类。将json串解析到自定义类中当json串为：1的时候。首先自定义一个类：12345   然后利用下面段代码将json反序列化到此类中：1利用12可以在控制台上看到输出的为：12将json串反序列化到系统自带的类中当json串是1用系统自带的map定义一个变量：mapstring, mapstring, object maps。然后利用maps = objectmapper.readvalue(json, map.class)便可将json反序列化到变量maps中。通过12可在控制台中得到下面的结果：12②渐次反序列化此方法更灵活，可以只将用户感兴趣的json串信息提取出来。主要利用objectmapper提供的readtree和jackson提供的jsonnode类来实现。测试例子1此json串比较复杂，包含了嵌套数组的形式，具有通用性。实现反序列化1234567891011在控制台下输出的结果是：1234结论：此方法类于xml解析中的dom方式解析，其好处是结构明细，便于提取想要的信息。当然，其缺点也和此方法一样：耗时费空间。三.总结jackson关于json的操作主要如上所示，其方法使用起来很便利，而且也很灵活，即提供了一次性完成的操作，也提供了可以按需读取信息的操作。并且jackson的功能很齐全，可以对序列化和反序列化进行多种细节的控制，例如注解功能和对于hibernate的延迟注入功能以及设置时间式功能等，因为这些功能目前不太需要，所以仔细研究留待以后。同时，jackson还支持对xml的一系列序列化和反序列化的操作，其思路与解析json的大致相同。

D0319895做过的一些水题的总结在蓝桥杯决赛的前一天，我整理了下这个博客，从一月份左右到现在现在一共是五十四篇，艾玛我写居然这么多了，加上去年暑假开始，也差不多一年了。至今的水平也是非常一般，所以做的都是入门级别的水题。回首一年之前，从台州oj到蓝桥杯题库到zoj到poj，也是一段有趣的历程很多题目的难度应该属于“熟练语言”级别的，姑且分成以下几个类别吧。【我保证以后写结题报告一定写题意！！光秃秃的代码太令人伤感了】**【语言基础篇】****超入门水题**蓝桥杯基础练习数列特征（求数列的最大、最小和总和，数字比较）蓝桥杯基础练习查找整数（查找数列中的整数返回序号问题，数组遍历）蓝桥杯基础练习回文数（输出回文数，二重循环）蓝桥杯基础练习数列排序（冒泡排序等）tzoj3093网上交作业的烦恼（素数判断）tzojjudgethesortedorder（判断是否为升序或降序，数字比较）tzoj3300三角形（三角形边长判断，条件判断）这个题貌当初没有过==tzoj3456三角形的个数（给出周长，求符合周长的不等边三角形个数，嵌套循环）tzoj3281:蛇行矩阵（输出一个有规律的数阵，找规律或二维数组）蓝桥杯basic-20数的读法（条件判断考虑到所有情况）蓝桥杯错误票据（找重复和缺漏的数字，排序）**进制转换**tzoj3107进制转换ii（二进制转换十六进制）tzoj3293:a变b（两个数字的二进制形式之间转变需要改变多少位，二进制转换）蓝桥杯基础练习十进制转十六进制蓝桥杯基础练习十六进制转十进制**字符串问题**蓝桥杯基础练习字母图形（考虑字母的ascii码和顺序的问题）蓝桥杯basic-15字符串对比蓝桥杯打印十字图（找规律，打印）tzoj3070隐藏的最大数字（处理字符串中的数字，求最大问题）tzoj3094祝福玉树（输出一个心形）tzoj1351:单词数（字符串中不同的单词个数，字符串处理函数）【注：首次调用时，s指向要分解的字符串，之后再次调用要把s设成null。strtok在s中查找包含在delim中的字符并用null('')来替换，直到找遍整个字符串。】tzoj2935破译密码（字符串中的字母转换）**【入门篇】****递推**蓝桥杯基础练习杨辉三角形（递推公式，现在看来简直就是入门级动态规划）**暴力破解**蓝桥杯基础练习特殊的数字（水仙花数，遍历破解）蓝桥杯基础练习特殊回文数（遍历破解）**贪心算法**hoj1052田忌赛马（比较基础的贪心）fatmouse'trade（部分背包，贪心，结构体排序）hoj2037今年暑假不ac（基础贪心，结构体排序）**背包问题**hoj1009fatmouse'trade（部分背包，贪心）**搜索**蓝桥杯带分数（全排列）hoj1016素数环（回溯dps）poj1190生日蛋糕（dps剪枝不是那么基础orz）poj1753flipgame（简单有界dps）poj2965thepilotsbrothers'refrigerator（和1753是一箭双雕题2333）poj1011sticks（简单dps）poj1321棋盘问题（类n皇后问题简单dps）poj1731orders(生成有重集的全排列1.0)poj1256anagram（生成有重集的全排列2.0）poj1543perfectcubes(水题dfs)poj1664放苹果（dfs/递归）poj1950desserts(dfs数据小运算)poj2386lakecountingdps解法（简单dfs）poj3278catchthatcow（简单入门级bfs）poj3126primepath（简单入门级bfs）

D0078693Linux系统监控、诊断工具之top命令详解接触  的人对于 top 命令可能不会陌生（不同系统名字可能不一样，如 ibm 的 aix 中叫 topas ），它的作用主要用来监控系统实时负载率、进程的资源占用率及其它各项系统状态属性是否正常。下面我们先来看张 top 命令的截图：amp;lt;img class=quot;aligncenter wp-image-4998quot; src=quot; alt=quot;quot; tilte=quot;quot; /amp;gt;amp;lt;/aamp;gt;amp;lt;/pamp;gt;（1）系统、任务统计信息：前 8 行是系统整体的统计信息。第 1 行是任务队列信息，同 uptime 命令的执行结果。其内容如下：01:06:48当前时间up 1:22系统运行时间，式为时:分1 user当前登录用户数load average: 0.06, 0.60,0.48系统负载，即任务队列的平均长度。三个数分别为 1分钟、5分钟、15分钟前到现在的平均。注意：这三个可以用来判定系统是否负载过高——如果持续大于系统 cpu 个数，就需要优化你的程序或者架构了。（2）进程、 cpu 统计信息：第 2~6 行为进程和cpu的信息。当有多个cpu时，这些内容可能会超过两行。内容如下：tasks: 29 total进程总数1 running正在运行的进程数28 sleeping睡眠的进程数0 stopped停止的进程数0 zombie僵尸进程数cpu(s): 0.3% us用户空间占用cpu百分比1.0% sy内核空间占用cpu百分比0.0% ni用户进程空间内改变过优先级的进程占用cpu百分比98.7% id空闲cpu百分比0.0% wa等待输入输出的cpu时间百分比0.0% hihardware irq 即“中断请求”的意思。0.0% sisoftware irq（3）最后两行为内存信息：mem: 191272k total物理内存总量173656k used使用的物理内存总量17616k free空闲内存总量22052k buffers用作内核缓存的内存量swap: 192772k total交换区总量0k used使用的交换区总量192772k free空闲交换区总量123988k cached缓冲的交换区总量。内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。ps：如何计算可用内存和已用内存？除了 free -m 之外，也可以看 top：shellmem:    255592k total,   167568k used,    88024k free,    25068k buffersswap:   524280k total,        0k used,   524280k free,    85724k cached12mem:255592k total,167568k used,88024k free,25068k buffersswap:524280k total,0k used,524280k free,85724k cached3.1 实际的程序可用内存数怎么算呢？the answer is: free  (buffers  cached)88024k  (25068k  85724k) = 198816k3.2 程序已用内存数又怎么算呢？the answer is: used – (buffers  cached)167568k – (25068k  85724k) = 56776k3.3 怎么判断系统是否内存不足呢？如果你的 swap used 数大于 0 ，基本可以判断已经遇到内存瓶颈了，要么优化你的代码，要么加内存。3.4 buffer 与cache 的区别a buffer is something that has yet to be “written” to disk. a cache is something that has been “read” from the disk and stored for later use 从应用程序角度来看，buffers/cached 是等于可用的，因为buffer/cached是为了提高文件读写的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被回收。所以从应用程序的角度来说，【可用内存】=【系统free memory】【buffers】【cached】buffers是指用来给块设备做的缓冲大小，他只记录文件系统的metadata以及 tracking in-fght pages.cached是用来给文件做缓冲。那就是说：buffers是用来存储，目录里面有什么内容，权限等等。而cached直接用来记忆我们打开的文件，如果你想知道他是不是真的生效，你可以试一下，先后执行两次cat 一个比较大的日志文件，比如nginx的access.log，你就可以明显的感觉到第二次的开打的速度快很多。因为linux将你暂时不使用的内存作为文件和数据缓存，以提高系统性能，当你需要这些内存时，系统会自动释放（不像windows那样，即使你有很多空闲内存,他也要访问一下磁盘中的pagefiles）（4）进程信息区：统计信息区域的下方显示了各个进程的详细信息。首先来认识一下各列的含义。序号列名含义apid进程idbppid父进程idcruserreal user nameduid进程所有者的用户ideuser进程所有者的用户名fgroup进程所有者的组名gtty启动进程的终端名。不是从终端启动的进程则显示为 ?hpr优先级ininice。负表示高优先级，正表示低优先级jp最后使用的cpu，仅在多cpu环境下有意义k%cpu上次更新到现在的cpu时间占用百分比ltime进程使用的cpu时间总计，单位秒mtime进程使用的cpu时间总计，单位1/100秒n%mem进程使用的物理内存百分比ovirt进程使用的虚拟内存总量，单位kb。virt=swaprespswap进程使用的虚拟内存中，被换出的大小，单位kb。qres进程使用的、未被换出的物理内存大小，单位kb。res=codedatarcode可执行代码占用的物理内存大小，单位kbsdata可执行代码以外的部分(数据段栈)占用的物理内存大小，单位kbtshr共享内存大小，单位kbunflt页面错误次数vndrt最后一次写入到现在，被修改过的页面数。ws进程状态。d=不可中断的睡眠状态r=运行s=睡眠t=跟踪/停止z=僵尸进程xcommand命令名/命令行ywchan若该进程在睡眠，则显示睡眠中的系统函数名zflags任务标志，参考 sched.h（5）查看指定列默认情况下仅显示比较重要的 pid、user、pr、ni、virt、res、shr、s、%cpu、%mem、time、command 列。可以通过下面的快捷键来更改显示内容：5.1 f 键选择显示内容通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。5.2 o 键改变显示顺序按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 a-z 可以将相应的列向左移动。最后按回车键确定。5.3 f/o 键将进程按列排序按大写的 f 或 o 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 r 键可以将当前的排序倒转。（6）常用交互命令从使用角度来看，熟练的掌握这些命令比掌握选项还重要一些。这些命令都是单字母的，如果在命令行选项中使用了s选项，则可能其中一些命令会被屏蔽掉。ctrl+l 擦除并且重写屏幕。h或者? 显示帮助画面，给出一些简短的命令总结说明。k 终止一个进程。系统将提示用户输入需要终止的进程pid，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。i 忽略闲置和僵死进程。这是一个开关式命令。q 退出程序。r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程pid以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。s 切换到累计模式。s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。f或者f 从当前显示中添加或者删除项目。o或者o 改变显示项目的顺序。l 切换显示平均负载和启动时间信息。m 切换显示内存信息。t 切换显示进程和cpu状态信息。c 切换显示命令名称和完整命令行。m 根据驻留内存大小进行排序。p 根据cpu使用百分比大小进行排序。t 根据时间/累计时间进行排序。w 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。123456789101112131415161718ctrll擦除并且重写屏幕。h或者?显示帮助画面，给出一些简短的命令总结说明。k终止一个进程。系统将提示用户输入需要终止的进程pid，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认是信号15。在安全模式中此命令被屏蔽。i 忽略闲置和僵死进程。这是一个开关式命令。q退出程序。r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程pid以及需要设置的进程优先级。输入一个正将使优先级降低，反之则可以使该进程拥有更高的优先权。默认是10。s切换到累计模式。s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成ms。输入0则系统将不断刷新，默认是5s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。f或者f从当前显示中添加或者删除项目。o或者o改变显示项目的顺序。l切换显示平均负载和启动时间信息。m 切换显示内存信息。t切换显示进程和cpu状态信息。c 切换显示命令名称和完整命令行。m根据驻留内存大小进行排序。p 根据cpu使用百分比大小进行排序。t根据时间/累计时间进行排序。w 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。（7）最后的技能：top 命令小技巧1、输入大写p，则结果按cpu占用降序排序。2、输入大写m，结果按内存占用降序排序。3、按数字 1 则可以显示所有cpu核心的负载情况。4、top -d 5    每隔 5 秒刷新一次，默认 1 秒5、top -p 4360,4358    监控指定进程6、top -u johndoe    ‘u’为 真实/有效/保存/文件系统用户名。7、top -u 500    ‘u’为有效用户标识8、top -bn 1    显示所有进程信息，top -n 1 只显示一屏信息，供管道调用9、top -m   #show memory summary in megabytes not kilobytes10、top -p 25097 -n 1 -b    # -b 避免输出控制字符，管道调用出现乱码11、top翻页：top -bn1 | less12345678910111、输入大写p，则结果按cpu占用降序排序。2、输入大写m，结果按内存占用降序排序。3、按数字1 则可以显示所有cpu核心的负载情况。4、top-d5 每隔5 秒刷新一次，默认1 秒5、top-p4360,4358监控指定进程6、top-ujohndoe ‘u’为真实/有效/保存/文件系统用户名。7、top-u500 ‘u’为有效用户标识8、top-bn1 显示所有进程信息，top-n1 只显示一屏信息，供管道调用9、top-m#show memory summary in megabytes not kilobytes10、top-p25097 -n1 -b# -b 避免输出控制字符，管道调用出现乱码11、top翻页：top-bn1| less

D0368278代理模式（静态代理和动态代理）一、代理模式   代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。   静态代理的一个代理只能代理一种类型，而且是在编译器就已经确定被代理的对象。而动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。二、静态代理   由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。静态代理的类图静态代理代码（在这里只贴主要代码，，有兴趣的可以下载看看）静态代理类的缺点：当如果接口加一个方法（把上面所有的代码的注释给去掉），所有的实现类和代理类里都需要做个实现。这就增加了代码的复杂度。动态代理就可以避免这个缺点。三、动态代理   动态代理类的源码是在程序运行期间由jvm根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。   动态代理在java中要想实现动态代理机制，需要java.lang.reflect.invocationhandler 接口和java.lang.reflect.proxy 类的支持。java.lang.reflect.invocationhandler接口的定义如下：objectproxy:被代理的对象（委托类）methodmethod:要调用的方法（委托类）object[]args:方法调用时所需要参数java.lang.reflect.proxy类的定义如下：——取得代理对象classloaderloader:类的加载器（委托类）class?interfaces:得到全部的接口（委托类）invocationhandlerh:得到invocationhandler接口的子类的实例（代理类）   大概看完这些，我们先来画一幅第一版的动态代理类图：   这是我第一版画的动态代理类图，为了显示动态代理的延迟加载，与真实的类解耦，我用了客户端，来表示运行时才会真正的去实例想要的真实类，动态代理类与真实类才会发生关系。但是，这个类图少了一些类，既然是类图，我们前面说的proxy类就没有在这里表现出来。所以，我改进了第二版动态代理图：   这张图就显示出了proxy和invocationhandler类，并且将上面说的invocationhandler和proxy如何实现动态代理的原理也捎带出来了。   有人说，代码就是最好的老师，也许有些人对这张图还是不太理解，没关系，看代码就行（在这里只贴主要代码，，有兴趣的可以下载看看）：四、思考：动态代理？aop？

D0428922Git学习笔记之Git常用命令git暂存区执行git status或者git diff命令时，扫描工作区改动的时候，先依据.git/index文件中记录的（用于跟踪工作区文件的）时间戳，长度等信息判断工作区文件是否改变，如果工作区文件的时间戳改变了，说明文件的内容可能被改变了，需要打开文件，读取文件内容，与更改前的原始文件相比，判断文件内容是否被更改。如果文件内容没有被更改，则将该文件新的时间戳记录到.git/index文件中。git checkout撤销暂存区中尚未提交的文件git checkout -- welcome.txt 撤销暂存区中的welcome.txt文件查看git版本信息git --version配置当前用户的姓名和邮箱git config --global user.name yournamegit config --global user.email youremailaddress配置命令别名git config --global alias.st status在git命令输出中开启颜色显示git config --global color.ui true初始化版本库git init在当前目录下初始化版本苦苦git init demo 在当前目录下新建demo文件夹，然后在demo中初始化版本库工作区文件内容搜索git grep 文件内容显示版本库.git所在的路径git rev-parse --git-dir显示工作区根目录git rev-parse --show-toplevel显示相对于工作区根目录的相对目录git rev-parse --show-prefix显示从当前目录后退到工作区根目录的深度git rev-parse --show-cdupgit config --globalglobal参数意义，在每个版本库.git目录中都会有一个config文件版本库中的配置文件config优先级最高，其次是全局配置文件--global最后是系统配置文件 --system删除git全局配置中的用户名和邮箱，git提交操作必须验证用户名和密码，如果没有设置用户名和密码，提交操作就会失败git config --unset --global user.namegit config --unset --global user.email查看版本库的提交日志git log --pretty=fuller显示详细的版本库提交日志git log --pretty==oneline在一行中显示版本库提交日志git log --stat加上--stat参数可以看到每次提交的文件变更统计git diff比较工作区与暂存区中的文件差异加上参数--cached或者--staged，比较的是暂存区与版本库中的文件差异git status加上-s参数，显示精简式的状态输出—m 如果工作区文件被修改后与暂存区文件信息不同，执行git status -s第二列会显示mm— 如果工作区文件与暂存区文件信息相同，而版本库中的文件信息与暂存区文件信息不同，则会在第一列显示mmm 如果工作区，暂存区和版本库中文件信息两两互不相同，则会显示两个mm

D0963482如何修改IOS7 Navigation Bar上的返回按钮文本颜色我想设置navigation bar的背景颜色为黑色,然后所有内部颜色为白色.因此,我用了这段代码:但是,返回按钮文本颜色,箭头颜色以及导航栏按钮的颜色仍然为默认颜色,怎么修改它们?解决方法 1:自从ios7后uinavigationbar的一些属性的行为发生了变化.你可以在下图看到:现在,如果你要修改它们的颜色,用下面的代码:

D0770268js最理想的继承——寄生组合式继承1.传统的组合式继承的缺点。传统的组合式继承，为了使子类拥有自己的实例属性，在子类的构造函数里调用了基类的构造函数，用于覆盖原型链继承的共享属性。所以，组合式继承会两次调用基类的构造函数：第一次，子类的原型声明为基类的一个实例；第二次，子类的构造函数中调用基类的构造函数。2.寄生组合式继承寄生组合式继承利用inherit()函数完成原型链的继承，这样我们就不需要专门为了原型继承，调用基类的构造函数。object.create(prototype,descpritor)是ecmascript5 中定义的方法，返回是生成对象，第一个参数是生成对象的原型，第二个是对象，用于定义属性或者方法（）。

D0760914单片机之花样流水灯最近学习了单片机，现在把流水灯的相关操作与大家分享一下单片机的编程语言是c语言，大家也应该很熟悉，那c语言是如何来控制开发板上的流水灯的呢？其实很简单 ：每一个led灯都有固定的位置,在reg52.h头文件中已经将led灯的位置与一个变量相对应。那么如何点亮一个led灯呢#includereg52.hsbit led1 = pi^0;void main(){led1 = 0;}这样就实现了led1灯的点亮/////////////////////////////////////////////////接下来我给大家介绍一下流水灯的循环闪烁（下面这段程序也可以用for循环进行书写，为了便于大家理解，从最简单的写法将起，自己可以试试用其他办法写）#includereg52.hsbit led1 = pi^0;sbit led2 = pi^1;sbit led3 = pi^2;sbit led4 = pi^3;sbit led5 = pi^4;unsigned int a;void main(){while(1){a = 10000;led1 = 0;while(a--);led1 = 1;led2 = 0;a = 10000;while(a--);//这两行代码是延时器led2 = 1;led3 = 0;a = 10000;while(a--);led3 = 1;led4 = 0;a = 10000;while(a--);led4 = 1;led5 = 0;a = 10000;while(a--);led5 = 1;}}这段程序就是使流水灯不断的循环闪烁，在街头的广告牌很是常见，红绿灯也是这种原理制作的。

D0455864腾讯Bugly参展北京2015QCon大会qcon是由infoq主办的全球顶级技术盛会，每年在伦敦、北京、东京、纽约、圣保罗、上海、旧金山召开。自2007年3月份首次举办以来，已经有超万名高级技术人员参加过qcon大会。qcon内容源于实践并面向社区，演讲嘉宾依据热点话题，面向5年以上的技术团队负责人、架构师、工程总监、高级开发人员分享技术创新和最佳实践。腾讯公司每年都组团参会，多位讲师上台分享产品和技术，同时还有多款产品在大会展出，其中腾讯bugly作为本次大会高级赞助商在现场引发参会者强烈关注。“修复应用崩溃，提升用户留存”的标语吸引了很多移动开发者驻足观看!腾讯bugly专注于移动应用崩溃监控，在实时监控、智能归类和全平台支持等方面超越国内主要竞争对手，获得参会者认可。现场前来咨询的有美团、京东、华为技术、去哪儿、1号店和蘑菇街等知名互联网企业技术负责人，他们提到一些实际工作中遇到的问题。例如：如何使用bugly对native崩溃进行分析和修复；对unity3d的c#脚本堆栈支持能力；sdk和不同系统、硬件的兼容性以及性能影响，都得到bugly产品负责人的详细解答。互联网技术媒体也对腾讯bugly表现出极大的兴趣，极客学院的运营总监bob来到bugly展台，跟bugly技术负责人陈淮就腾讯bugly在移动应用开发中的作用进行了深入探讨，并提出了一些开发者关心的问题。例如：如何接入bugly崩溃监控sdk，如何借助bugly平台提升应用质量等。针对这些问题，bugly技术负责人陈淮详细介绍了应用接入腾讯bugly的经过，并且分享了腾讯内部产品使用bugly解决问题的经验。想第一时间了解腾讯开发哥是如何借助bugly进行崩溃问题分析，可以关注公众号腾讯bugly了解更多精彩内容。关注腾讯bugly微信公众号，了解更多信息

D0825229设计模式学习之策略模式：容错恢复机制容错恢复机制应用程序开发中常见的功能程序运行的时候，正常情况下应该按某种方式来做，如果按照某种方式来做发生错误的话，系统并不会崩溃，而是继续运行，能提供出错后的备用方案。日志记录的例子把日志记录到数据库和日志记录到文件当做两种记录日志的策略日志记录的策略接口：把日志写到文件的策略：把日志写到数据库的策略：日志上下文，包含一个策略对象，实现了对错误的处理客户端调用：

D0943630黑马程序员---装饰类设计模式------- a href= target=blankandroid培训/a、a href= target=blankjava培训/a、期待与您交流！ ----------装饰模式比继承要灵活，避免了集成体系的臃肿而且降低了类与类之间的关系装饰类因为增强已有对象，具备的功能和已有的对象是相同的，只不过提供了更强的功能，所以装饰类和被装饰类都是属于一个体系中。bufferedinputstreamm也是一个装饰类，下面是我自定义的一个bufferedinputstreamm类，把read()方法按照我们的想法实现出来

D0089205Linux(centos)系统各个目录的作用详解文件系统的类型linux有四种基本文件系统类型：普通文件、目录文件、连接文件和特殊文件，可用file命令来识别。普通文件：如文本文件、c语言元代码、shell脚本、二进制的可执行文件等，可用cat、less、more、vi、emacs来察看内容，用mv来改名。目录文件：包括文件名、子目录名及其指针。它是linux储存文件名的唯一地方，可用ls列出目录文件。连接文件：是指向同一索引节点的那些目录条目。用ls来查看是，连接文件的标志用l开头，而文件面后以-指向所连接的文件。特殊文件：linux的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特殊文件，常放在/dev目录内。例如，软驱a称为/dev/fd0。linux无c：的概念，而是用/dev/had来自第一硬盘。 对于linux新手来说，最感到迷惑的问题之一就是文件都存在哪里呢?特别是对于那些从windows转过来的新手来说，linux的目录结构看起来有些奇怪哦。所以，在这里讲一下linux下的主要目录以及它们都是用来干什么的。 / this is the root directory. the mothership. the home field. the one and only top directory for your whole computer.everything, and i mean everything starts here. when you type ‘/home’ what you’re really saying is “start at / and then go to the home directory.” / 这就是根目录。对你的电脑来说，有且只有一个根目录。所有的东西，我是说所有的东西都是从这里开始。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/(根目录)开始，再进入到home目录。 /root this is where the root user lives.the root user is the god of your system. root can do anything, up to and including removing your entire filesystem. so be careful using root. /root 这是系统管理员(root user)的目录。对于系统来说，系统管理员就好比是上帝，它能对系统做任何事情，甚至包括删除你的文件。因此，请小心使用root帐号。 /bin here’s where your standard linux utilities(read programs) live — things like “ls” and “vi” and “more”. generally this directory is included in your path. what this means is that if you type ‘ls’, /bin is one of the places your shell will look to see if ‘ls’ means anything. /bin 这里存放了标准的(或者说是缺省的)linux的工具，比如像“ls”、“vi”还有“more”等等。通常来说，这个目录已经包含在你的“path”系 统变量里面了。什么意思呢?就是：当你在终端里输入ls，系统就会去/bin目录下面查找是不是有ls这个程序。 /etc here’s where the administrative and systemconfiguration stufflives. for instance, if you have samba installed, and you want to modify the samba configuration files, you’d find them in /etc/samba. /etc 这里主要存放了系统配置方面的文件。举个例子：你安装了samba这个套件，当你想要修改samba配置文件的时候，你会发现它们(配置文件)就在/etc/samba目录下。 /dev here’s where files that controlperipherals live. talking to a printer? your computer is doing it from here. same goes for disk drives, usb devices, and other such stuff. /dev 这里主要存放与设备(包括外设)有关的文件(unix和linux系统均把设备当成文件)。想连线打印机吗?系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、usb驱动等都放在这个目录。 /home here’s where your data is stored. config files specific to users, your desktop folder(whick makes your desktop what it is), and any data related to your user. each user will have their own /home/username folder, with the exception of the root user. /home 这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。 /tmp this is the temporary folder. think of it as a scratch directory for your linux system. files that won’t be needed by programs once their used once or twice are put here. many linux systems are set toautomatically wipethe /tmp folder at certain intervals, sodon’t put things you want to keep here. /tmp 这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。有些linux系统会定期自动对这个目录进行清理，因此，千万不要把重要的数据放在这里。 /usr here’s where you’ll find extra utilities that don’t fit under /bin or /etc. things like games, printer utilities, and whatnot. /usr is divided into sections like /usr/bin for programs, /usr/share for shared data like sound files or icons, /usr/lib for libraries whick cannot be directly run but are essential for running other programs.your package manager takes care of the things in /usr for you. /usr 在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具拉等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序;/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等;/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器(应该是“新立得”吧)会自动帮你管理好/usr目录的。 /opt here’s whereoptional stuffis put. trying out the latest firefox beta? install it to /opt where you can delete it without affecting other settings.programs in here usually live inside a single folder whick contains all of their data, libraries, etc. /opt 这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。 举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。 /usr/local this is where mostmanually installed(ie. outside of your package manager) software goes.it has the same structure as /usr.it is a good idea to leave /usr to your package manager and put any custom scripts and things into /usr/local, since nothing important normally lives in /usr/local. /usr/local 这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。 /media some distros use this folder to mount things like usb disks, cd or dvd drives and other filesystems. /media 有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘(包括u盘)、cd/dvd驱动器等等。补充： /bin 系统所需要的那些命令位于此目录，比如 ls、cp、mkdir等命令；功能和/usr/bin类，这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里（/usr/bin和/usr/sbin 类与“/”根目录下对应的目录（/bin和/sbin），但不用于基本的启动（譬如，在紧急维护中）。大多数命令在这个目录下。）。  /boot linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，grub或lilo系统引导管理器也位于这个目录。/lostfound 在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损 坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。/mnt 这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。可以参看/etc/fstab的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看/etc/fstab中怎 么定义了；比如光驱可以挂载到/mnt/cdrom 。/opt 表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在fedora core 5.0中，openoffice就是安装在这里。有些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以通过./configure --prefix=/opt/目录 。/proc 操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见 /etc/fstab 。/sbin 大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/x11r6/sbin或/usr/local/sbin目录是相的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。/usr 这个是系统存放程序的目录，比如命令、帮助文件等。这个目录下有很多的文件和目录。当我们安装一个linux发行版官方提供的软件包时，大多安装在这里。 如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。/usr目录下包括涉及字体目录/usr/share/fonts ，帮助目录 /usr/share/man或/usr/share/doc，普通用户可执行文件目录/usr/bin 或/usr/local/bin 或/usr/x11r6/bin ，超级权限用户root的可执行命令存放目录，比如 /usr/sbin 或/usr/x11r6/sbin 或/usr/local/sbin 等；还有程序的头文件存放目录/usr/include。/var 这个目录的内容是经常变动的，看名字就知道，我们可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/www目录是定义apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如mysql的，以及mysql数据库的的存放地；关于/opt目录的一个小技巧在linux中，/opt目录是存放某些大型软件或者某些特殊软件的目录，比如谷歌浏览器(google chrome)默认就是安装在/opt中。但是我们一般不会把opt单独分在一个区，因为/opt中大多数时候是空的，即使安装了软件也不会太多，而且有 些软件的容量还比较大，这样就会占用/的容量，我们可以在其它你愿意的地方建立一个目录来将/opt“转移”到别处，比如我的的/usr是单独分在一个 区，容量有50g，这么大的空间不要浪费了不是？而且/usr本来就是安装软件的地方，所以我可以/usr下建立一个叫opt的文件夹，然后右键点击这个 /usr下的opt，选择“创建链接”，得到一个名为“到 opt 的链接”文件，然后把这个文件剪切到/下，将原来的/opt删除，再将“到 opt 的链接”改名为opt就可以了，以后我们安装在/opt的软件实际上是安装到了/usr/opt下（实际上是一个符号链接）。/usr/local 这个目录一般是用来存放用户自编译安装软件的存放目录；一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。这个目录下面有子目录。自己看看吧。/usr/share 系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。/var/log 系统日志存放，分析日志要看这个目录的东西；/var/spool 打印机、邮件、代理服务器等假脱机目录；转地址：

D0266482bst double Linked Liststructbstreenode//二分查找树中的一个节点{intm_nvalue;// 节点的bstreenode*m_pleft;// 左指针域bstreenode*m_pright;// 右指针域};然后,我们就可以根据以上递归的思想一步一步写出c源码了bstreenode* convertnode(bstreenode* pnode,boolasright){//如果是空数,那么返回空指针if(!pnode)returnnull;//定义两个指针,存放当前节点的左双向链表的根河和右双向链表的根bstreenode *pleft = null;bstreenode *pright = null;//先将左子数转换为双向链表,注意这里的第二个参数是false,表示左子数节点转换为左双向链表if(pnode-m_pleft)pleft = convertnode(pnode-m_pleft,false);//如果左双向链表不为空,那么就正确地链接到当前节点pnode上if(pleft){pleft-m_pright = pnode;pnode-m_pleft = pleft;}//再将右子数转换为双向链表,注意这里的第二个参数是true,表示右子数节点转换为右双向链表if(pnode-m_pright)pright = convertnode(pnode-m_pright,true);//如果右双向链表不为空,那么就正确地链接到当前节点pnode上if(pright){pnode-m_pright = pright;pright-m_pleft = pnode;}//到了这里,当前节点pnode以及它的子数已经被转换为双向链表了,最后一步,就是怎样将转换好的双向链表的头指针返回呢?显然,我们应该根据当前节点在原子数中的位置判断,如果当前节点pnode在原来的树种是以右节点的形式存在的,那么以当前节点为头指针的双向链表应该返回整个以pnode为根节点的子数中最小的节点,也即最左的节点,反之,则返回最右的节点,以下代码便是这段文字的代码描述bstreenode *ptemp = pnode;if(asright){while(ptemp-m_pleft)ptemp = ptemp-m_pleft;}else{while(ptemp-m_pright)ptemp = ptemp-m_pright;}returnptemp;}最后,我们就可以用一个主函数来对以上一段程序进行包装,以形成一个独立功能的函数bstreenode* convert(bstreenode* pheadoftree){//这里,第二个参数为true,即把整个树当做是右子数看待,这样,最终就能返回整个树中的最小的节点了.returnconvertnode(pheadoftree,true);}思路之二是中序遍历二元查找树,由于中序遍历是从小到大遍历的,所以可以假设在遍历某一个子树的根节点的时候其左子树已经是一个排序双向链表了,并且如果再得到该双向链表的为指针,可以很轻易地将其与根节点相连,然后同样可以使得右子数成为一个排序双向链表,然后将根节点轻而易举的链接到右子数组成的排序双向链表.//此函数的功能是将以pnode为根的树转换为排序双向链表,并且将她链接到以plastnodeinlist为已经调整好的双向链表的尾节点上voidconvertnode(bstreenode* pnode, bstreenode* plastnodeinlist){if(pnode == null)return;bstreenode *pcurrent = pnode;//装换左子树if(pcurrent-m_pleft != null)convertnode(pcurrent-m_pleft, plastnodeinlist);//将当前节点链接到已调整好的双向链表的尾节点,plastnodeinlist为已经转换好的双向链表的尾指针pcurrent-m_pleft = plastnodeinlist;if(plastnodeinlist != null)plastnodeinlist-m_pright = pcurrent;//然后当前节点就成了双向链表中的最后一个节点plastnodeinlist = pcurrent;//所以转换右子数的时候,可以很顺利地将双向链表中的最后一个节点与右子数装换好的双向链表相连if(pcurrent-m_pright != null)convertnode(pcurrent-m_pright, plastnodeinlist);}bstreenode* convert_solution1(bstreenode* pheadoftree){//由于一开始已经调整好的双向链表为空,所以尾指针为空bstreenode *plastnodeinlist = null;//将整个树转换为双向链表的时候,plastnodeinlist就成了链表中的最后一个节点convertnode(pheadoftree, plastnodeinlist);//然后链表指针不断向前移动,便得到了头节点的指针bstreenode *pheadoflist = plastnodeinlist;while(pheadoflist  pheadoflist-m_pleft)pheadoflist = pheadoflist-m_pleft;returnpheadoflist;}将排序二叉树转化成双向链表，应该是一道很常见的面试题目，网上的实现比较多，有用递归也有用中序遍历法的。看到一位外国友人的实现，还是比较清晰的，思路如下：1，如果左子树不为null，处理左子树 1.a）递归转化左子树为双向链表； 1.b）找出根结点的前驱节点（是左子树的最右的节点） 1.c）将上一步找出的节点和根结点连接起来2，如果右子树不为null，处理右子树（和上面的很类） 1.a）递归转化右子树为双向链表； 1.b）找出根结点的后继节点（是右子树的最左的节点） 1.c）将上一步找出的节点和根结点连接起来3，找到最左边的节点并返回附上国外友人的链接：下面是代码实现：bintree2listutil函数返回的node＊ 是root节点，bintree2list函数返回的是头节点

D027341311gR2 集群(CRS/GRID)新功能——SCAN(Single Client Access Name)本文简单的介绍一下11gr2集群(crs/grid)新功能scan(single client access name),希望对于刚刚接触11gr2的朋友有一些帮助。在介绍scan之前，先简单的回顾一下oracle关于ip地址的使用，在9i rac时，oracle没有自己的clusterware，主要依靠第三方的集群软件（如ibm hacmp等等），客户端主要是通过public ip来访问数据库（如果第三方集群软件提供服动ip的话，也可以通过这个服动ip来访问数据库），当某一个节点已经出现故障无法对外提供服务时，如果客户端继续请求连接这个节点的public ip，那么连接请求会长时间没有返回，最后要等到tcp-ip timeout （tcp-ip超时时间一般为10分钟，不同os这个不同）才会返回一个超时信息，这对于实时性要求较高的应用来说是致命的问题，很多dba都经历过这样的问题，从技术层面上来说，这是一个网络层的问题，任何应用都要等待网络层返回超时信息。为了解决这个问题，从oracle 10g rac开始，引入了一个新的功能叫vip，这个功能类于第三方集群软件的浮动ip,简单的说就是当public 网卡或者节点出现问题，vip可以快速的failover到另外的节点，如果客户端的连接请求被分配到这个vip时，客户端连接请求马上就会遇到错误，因此会快速的跳过这个‘有问题的’vip，而重新分配另一个vip（这个功能是客户端连接时的failover），最终连接到数据库，这些对于应用来说是透明的，基本感觉不到连接的延时。scan简介-------------------从11gr2 grid infrastructure (crs/clusterware)开始，引入了一个新功能叫scan (single client access name)，scan是一个域名，可以解析至少1个ip，最多解析3个scan ip，客户端可以通过这个scan 名字来访问数据库，scan的好处就是当集群中新增加了节点或者删除了节点，不需要额外维护客户端。在11gr2上，客户端仍然可以继续使用原有的 vip，但是oracle推荐使用scan。scan ip必须与public ip和vip在一个子网，同时oracle推荐使用dns或者gns(11gr2 新功能)来解析scan，如果没有使用dns或者gns的话，可以使用hosts文件，但是这个办法不是oracle推荐的，因为这个方法只能定义一个 scan ip。grid集群中有2类资源是与scan有关的，一类是scan ip，另一类是scan listener，scan ip和scan listener是成对出现的，也就是说如果有3个scan ip，就会同时有3个scan listene。scan ip就是dns解析的ip地址，scan listener的作用是接受客户端的连接请求。查看scan ip信息和scan listener信息的方法在后文介绍。数据库的初始化参数remote_listener默认被设置为scan listener，目的是为了让scan listener可以监听所有的实例，记录所有实例的压力，以便于按照负载均衡的方式来转发客户端的请求。客户端如何通过scan访问数据库-------------------------------------------客户端发出连接数据库的请求，dns将scan解析出对应的3个scan ip并返回给客户端，客户端随机的选择其中一个scan ip地址，然后客户端通过这个scan ip访问对应的节点，当对应节点的scan listener接受到请求后，scan listener会选择压力最小的数据库实例，然后压力最小的数据库实例对应的local listener的地址将会返回给客户端，最终这个local listener为客户端请求建立与数据库的连接。客户端tnsnames.ora的配置-------------------------------------------rac =(description =(address = (protocol = tcp)(host= rac-cluster-scan)(port = 1521))(connect_data =(server = dedicated)(service_name = rac)) )客户端的连接方式-------------------------------------------$ sqlplsu /@racezconnet的连接仍然适用于scan$ sqlplus /@rac-cluster-scan:1521/rac常用命令-----------------------1. 查看scan配置信息$ srvctl config scanscan name: rac-cluster-scan, network: 1/192.168.1.0/255.255.255.0/scan vip name: scan1, ip: /rac-cluster-scan/192.168.1.12scan vip name: scan2, ip: /rac-cluster-scan/192.168.1.13scan vip name: scan3, ip: /rac-cluster-scan/192.168.1.142. 查看scan listener配置信息$ srvctl config scan_listenerscan listener listener_scan1 exists. port: tcp:1521scan listener listener_scan2 exists. port: tcp:1521scan listener listener_scan3 exists. port: tcp:15213. 查看scan的状态$ srvctl status scan4. 查看scan listener的状态$ srvctl status scan_listener常用文档------------------scan介绍oracle support网站上查看下面2篇文章，都是关于scan的介绍，希望能够帮助您理解关于scan的问题：11gr2 grid infrastructure single client access name (scan) explained (doc id 887522.1)how to setup scan listener and client for taf and load balancing [video] (doc id 1188736.1)同时推荐您学习oracle的在线文档，里面有很详细的介绍，包括新功能，crs/rac 安装过程和常用的管理命令，基本上可以解决我们平时遇到的大部分疑问。集群（grid/crs）的安装和管理文档：rac的安装和管理文档：----jialin.lee2012-01-18

D0208342iOS NSNotificationCenter 使用姿势详解最近在做平板的过程中，发现了一些很不规范的代码。偶然修复支付bug的时候，看到其他项目代码，使用通知的地方没有移除，我以为我这个模块的支付闪退是因为他通知没有移除的缘故。而在debug和看了具体的代码的时候才发现和这里没有关系。在我印象中，曾经因为没有移除通知而遇到闪退的问题。所以让我很意外，于是写了个demo研究了下，同时来讲下nsnotificationcenter使用的正确姿势。nsnotificationcenter对于这个没必要多说，就是一个消息通知机制，类广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个nsnotificationcenter，让我们可以很方便的进行通知的注册和移除。然而，有些人的姿势还是有点小问题的，下面就看看正确的姿势吧！正确姿势之remove只要往nsnotificationcenter注册了，就必须有remove的存在，这点是大家共识的。但是大家在使用的时候发现，在uiviewcontroller中addobserver后没有移除，好像也没有挂！我想很多人可能和我有一样的疑问，是不是因为使用了arc？在你对象销毁的时候自动置为nil了呢？或者苹果在实现这个类的时候用了什么神奇的方式呢？下面我们就一步步来探究下。首先，向nsnotificationcenter中addobserver后，并没有对这个对象进行引用计数加1操作，所以它只是保存了地址。为了验证这个操作，我们来做下代码的测试。一个测试类，用来注册通知：123456789101112131415161718192021这个类很简单，就是在初始化的时候，给他注册一个通知。但是在销毁的时候不进行remove操作。我们在vc中创建这个对象后，然后销毁，最后发送这个通知：12345678在进入这个vc后，我们发现挂了。。而打印出的信息是：1我们可以发现，向野指针对象发送了消息，所以挂掉了。从这点来看，苹果实现也基本差不多是这样的，只保存了个对象的地址，并没有在销毁的时候置为nil。这点就可以证明，addobserver后，必须要有remove操作。现在我们在uiviewcontroller中注册通知，不移除，看看会不会挂掉。1234首先用navigationcontroller进入到这个页面，然后pop出去。最后点击发送通知的按钮事件：1234无论你怎么点击这个按钮，他就是不挂！这下，是不是很郁闷了？我们可以找找看，你代码里面没有remove操作，但是nsnotificationcenter那边已经移除了，不然肯定会出现上面野指针的问题。看来看去，也只能说明是uiviewcontroller自己销毁的时候帮我们暗地里移除了。那我们如何证明呢？由于我们看不到源码，所以也不知道有没有调用。这个时候，我们可以从这个通知中心下手！！！怎么下手呢？我只要证明uiviewcontroller在销毁的时候调用了remove方法，就可以证明我们的猜想是对的了！这个时候，就需要用到我们强大的类别这个特性了。我们为nsnotificationcenter添加个类别，重写他的- (void)removeobserver:(id)observer方法：1234这样在我们vc中导入这个类别，然后pop出来，看看发生了什么！1怎么样？是不是可以证明系统的uiviewcontroller在销毁的时候调用了这个方法。（不建议大家在开发的时候用类别的方式覆盖原有的方法，由于类别方法具有更高的优先权，所以有可能影响到其他地方。这里只是调试用）。以上也提醒我们，在你不是销毁的时候，千万不要直接调用[[nsnotificationcenter defaultcenter] removeobserver:self];这个方法，因为你有可能移除了系统注册的通知。正确姿势之注意重复addobserver在我们开发中，我们经常可以看到这样的代码：1234567891011就是在页面出现的时候注册通知，页面消失时移除通知。你这边可要注意了，一定要成双成对出现，如果你只在viewwillappear 中 addobserver没有在viewwilldisappear 中 removeobserver那么当消息发生的时候，你的方法会被调用多次，这点必须牢记在心。正确姿势之多线程通知首先看下苹果的官方说明：regular notification centers deliver notifications on the thread in which the notification was posted. distributed notification centers deliver notifications on the main thread. at times, you may require notifications to be delivered on a particular thread that is determined by you instead of the notification center. for example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. in these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.意思很简单，nsnotificationcenter消息的接受线程是基于发送消息的线程的。也就是同步的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作ui必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。下面看个示例代码12345678910111213141516171819202122总结通知平常使用的知识点差不多就这么多。希望对大家有帮助。最后，代码一定要养成良好的习惯，该移除的还是要移除。

D0405807DB2常用命令总结====================db2组件相关====================1、 打开命令行窗口 #db2cmd 2、 打开控制中心#db2cmd db2cc3、 打开命令编辑器#db2cmd db2ce====================db2配置相关====================1、 查看db2诊断日志#db2diag2、 查看命令帮助#db2 ? [command]3、 查看错误码信息#db2 ? [sqlcode]4、 列出数据库管理配置（实例级）#db2 get dbm cfg5、 列出数据库管理配置 （数据库级）#db2 get db cfg for [dbname]6、 获取某数据库管理配置信息#db2 get db cfg for[dbname]7、打开在线备份支持#db2 update db cfg for[dbname]using userexit on 启用用户出口#db2 update db cfg for[dbname]using logretain on 启用归档日志#db2 update db cfg for[dbname]using trackmod on 启用增量备份功能8、获取数据库管理器的快照数据#db2 –v get snapshot for dbm9、编目node#db2 catalog tcpip node [nodename] remote [ip] server [port]10、编目数据库#db2 catalog database [databasename] as alias_name at node [nodename]11、反编目数据库#db2 uncatalog db [databasename]12、反编目node#db2 uncatalog node [nodename]13、查看版本#db2level14、设置实例系统启动时是否自动启动#db2iauto -on 自动启动 #db2iauto -off 不自动启动15、清除已delete的数据，优化数据结构的reorg和runstatsdb2 reorg table [tablename]db2 runstats on table [tablename] with distribution and indexes all====================db2实例相关====================1、创建db2实例#db2icrt [instancename]2、删除db2实例#db2idrop[instancename]3、显示当前数据库管理实例#db2 get instance4、设置当前db2实例#set db2instance=[instancename]5、显示db2拥有的实例#db2ilist6、 启动数据库实例#db2start7、 停止数据库实例#db2stop或者#db2stop force====================db2连接相关====================1、 连接到数据库#db2 connect to [dbname] user [username] using [password]2、 断开数据库连接#db2 connect reset 或者#db2terminate3、 查看使用数据库的应用#db2 list applications for db [dbname]4、 强制断开所有应用#db2 force application all ====================db2查看相关====================1、 列出所有node#db2 list node directory2、列出所有数据库#db2 list db directory3、 列出所有激活的数据库#db2 list active databases4、 列出所有用户表#db2 list tables 或者#db2 list tables for user5、列出所有系统表#db2 list tables for system6、列出所有表#db2 list tables for all7、列出特定用户表#db2 list tables for schema [schemaname]8、 查看应用进程号#db2 list applications show detail====================db2数据库相关====================1、 创建数据库#db2 create db [dbname]usingcodesetgbkterritorycncollateusingidentity2、 删除数据库#db2 drop database [dbname]====================db2缓冲池相关====================1、 创建缓冲池#db2createbufferpoolbp32kallnodessize-1pagesize32k====================db2表空间相关====================1、 创建临时表空间 #db2 create user temporary tablespace t_tbs pagesize 32k managed by database using (file 'd:\t_tbs.f1' 10000) extentsize 2562、 创建普通表空间#db2createregulartablespace t_tbs pagesize32kmanagedbydatabaseusing (file'd:\t_tbs.f1' 5g)bufferpoolbp32k3、查看当前数据库表空间分配状况#db2 list tablespaces show detail====================schema相关====================1、修改当前模式#db2 set schema [schemaname]====================db2表相关====================1、 创建一个与数据库中某个表(t2)结构相同的新表(t1)#db2 create table t1 like t22、 将一个表t1的数据导入到另一个表t2#db2 insert into t1 select * from t23、以默认分隔符加载,默认为“,”号#db2 import from btpoper.txt of del insert into btpoper 4、以指定分隔符“|”加载#db2 import from btpoper.txt of del modified by coldel| insert into btpoper5、 显示表结构 #db2 describe table [tablename]====================db2列相关====================1、修改列数据类型#db2 alter table [tablename] alter column [columname] set data type varchar(24) ====================db2数据库备份相关====================backup和restore方式：1、 离线（脱机）备份数据库并返回时间戳#db2 backup db[dbname] use [path]2、 在线（联机）备份数据库并返回时间戳#db2 backup db[dbname]online use[path]3、在开启必须的三个参数的情况下的增量备份并返回时间戳#db2 backup db[dbname]online incremental use [path] 或者#db2 backup db[dbname]online incremental delta use[path]4、 查看备份的记录#db2 list history backup all for[dbname]或者#db2adutl query5、 恢复数据库#db2 restore db[dbname] from [path] into [newdatabasename]db2move方式：1、 export导出数据#db2move [dbname] export -u username -p password 或者#db2move[dbname]export -sn [schema name] 或者#db2move[dbname]export -ts [tablespace name] 或者#db2move[dbname]export -tc [table creator] 或者#db2move[dbname]export -tn [table name] 或者#db2move[dbname]export -tf [file name] (文件中每行只能列出一个完整的表名)2、 import导入数据#db2move[dbname]import 或者#db2move[dbname]import -io create 或者#db2move[dbname]import -io insert 或者#db2move[dbname]import -io insert_update 或者#db2move[dbname]import -io replace 或者#db2move[dbname]import -io replace_create3、 load导入数据 #db2move[dbname]load 或者#db2move[dbname]load -lo insert 或者#db2move[dbname]load -lo replaceexport和import方式：1、导出del式#export to /home/backup/mysql.txt of del select * from [tablename]2、导出ixf式#export to /home/backup/mysql.ixf of ixf select * from[tablename]3、记录导出过程中的message#export to /home/backup/mysql.ixf of ixfmessages/home/backup/mysql.msg select * from [tablename]4、导入数据#import from /home/movedata/mysql.ixf of ixf insert into [tablename]5、导入时忽略自增列#import from /home/movedata/mysql.ixf of ixf modified by identityignore insert into[tablename]6、建表并导入数据#import from /home/movedata/mysql.ixf of ixf create into [tablename]db2look提取数据库结构ddldb2look –d [databasename] -z [schemaname] –a –e –x–c–l–o mysql.sql====================db2脚本相关====================1、 执行脚本文件#db2 -tvf scripts.sql

D0466794Creating a WCF Service从今天起开始跟着一个教程写一个关于wcf的系列博客，希望能够坚持下来。作为第一篇，来一个简单点的，创建一个wcf服务。先看一张整体的图片。 通过上图可以看出，就是想通过一个wcf服务，来满足两个客户端的需求。一个是java web服务通过http访问，另一个则是windows web 服务通过tcp访问。下面开始实战。 1.创建wcf服务  先创建一个类库，名称是helloservice，然后在此类库中创建wcf服务。    2.创建完后，我们会看到，wcf一个接口和一个实现类，并且有了一个dowork的方法。我们做一下修改，把方法名称修改为dowork，并在实现类中做一下实现。具体代码如下： 3.创建宿主  在第二步中就已经把wcf服务创建好了，由于服务是依赖于宿主的，所以我们得为服务找一个安身的场所。  新建控制台应用程序，名称为helloservicehost。在此需要添加wcf核心库using system.servicemodel，并添加上述wcf类库的引用，添加配置文件，并在配置文件中做一下修改。  配置文件完成后，我们就开始启动我们的服务，在宿主中运行服务。具体代码如下：  经过以上操作，就把我们写好的helloservice寄宿在我们的宿主中，并且启动成功，对外的地址是http://localhost:8080，可以访问地址，如果出现下述界面的话，代表成功。4.创建window web应用程序  服务发布成功后，下面就创建一个web应用程序来访问我们的服务。  新建hellowebclient网站应用程序，并添加服务应用。此时需要启动宿主中的服务。    这样就把我们刚才的服务引用添加其中。下面做一个简单的页面，就一个文本框，命令按钮和一个label，功能调用我们的服务，让label中现实文本框中的文本。具体代码如下：最终效果如下图 5.小结 通过上述一系列的操作，就完成了一个wcf服务的创建，下一节的内容是wcf服务实现多个契约。 本篇博客的源码地址：

D0061553各种排序算法的分析及java实现　　排序一直以来都是让我很头疼的事，以前上《数据结构》打酱油去了，整个学期下来才勉强能写出个冒泡排序。由于下半年要准备工作了，也知道排序算法的重要性（据说是面试必问的知识点），所以又花了点时间重新研究了一下。　　排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。　　内排序有可以分为以下几类：　　(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。　　(2)、选择排序：简单选择排序、堆排序。　　(3)、交换排序：冒泡排序、快速排序。　　(4)、归并排序　　(5)、基数排序一、插入排序•思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。•关键问题：在前面已经排好序的序列中找到合适的插入位置。•方法：–直接插入排序–二分插入排序–希尔排序①直接插入排序（从后向前找到合适位置后插入）　　1、基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。　　2、实例　　　　3、java实现　　4、分析　　直接插入排序是稳定的排序。关于各种算法的稳定性分析可以参考　　文件初态不同时，直接插入排序所耗费的时间有很大差异。若文件初态为正序，则每个待插入的记录只需要比较一次就能够找到合适的位置插入，故算法的时间复杂度为o(n)，这时最好的情况。若初态为反序，则第i个待插入记录需要比较i1次才能找到合适位置插入，故时间复杂度为o(n2)，这时最坏的情况。　　直接插入排序的平均时间复杂度为o(n2)。②二分法插入排序（按二分法找到合适位置插入）　　1、基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里是按二分法找到合适的位置，可以减少比较的次数。　　2、实例　　3、java实现　　4、分析　　当然，二分法插入排序也是稳定的。　　二分插入排序的比较次数与待排序记录的初始状态无关，仅依赖于记录的个数。当n较大时，比直接插入排序的最大比较次数少得多。但大于直接插入排序的最小比较次数。算法的移动次数与直接插入排序算法的相同，最坏的情况为n2/2，最好的情况为n，平均移动次数为o(n2)。③希尔排序　　1、基本思想：先取一个小于n的整数d1作为第一个，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行；然后，取第二个增量d2d1重复上述的分组和排序，直至所取的增量dt=1(dtdt-l…d2d1)，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。　　2、实例　3、java实现　　4、分析　　我们知道一次插入排序是稳定的，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。　　希尔排序的时间性能优于直接插入排序，原因如下：　　（1）当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。　　（2）当n较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度o(n)和最坏时间复杂度0(n2)差别不大。　　（3）在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。　　因此，希尔排序在效率上较直接插人排序有较大的改进。　　希尔排序的平均时间复杂度为o(nlogn)。二、选择排序•思想：每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。•关键问题：在剩余的待排序记录序列中找到最小关键码记录。•方法：–直接选择排序–堆排序①简单的选择排序　　1、基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。　　　　2、实例　　3、java实现 　4、分析　　简单选择排序是不稳定的排序。　　时间复杂度：t(n)=o(n2)。②堆排序　　1、基本思想：　　堆排序是一种树形选择排序，是对直接选择排序的有效改进。　　堆的定义下：具有n个元素的序列 （h1,h2,...,hn),当且仅当满足（hi=h2i,hi=2i1）或（hi=h2i,hi=2i1） (i=1,2,...,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二 叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。　　思想:初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个 堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。　　2、实例初始序列：46,79,56,38,40,84　　建堆：　　交换，从堆中踢出最大数依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。　　3、java实现　　4、分析　　堆排序也是一种不稳定的排序算法。　　堆排序优于简单选择排序的原因：　　直接选择排序中，为了从r[1..n]中选出关键字最小的记录，必须进行n-1次比较，然后在r[2..n]中选出关键字最小的记录，又需要做n-2次比较。事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。　　堆排序可通过树形结构保存部分比较结果，可减少比较次数。　　堆排序的最坏为o(nlogn)。堆序的平均性能较接近于最坏性能。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。三、交换排序①冒泡排序　　1、基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。　　2、实例　　3、java实现　　4、分析　　冒泡排序是一种稳定的排序方法。　•若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为n-1，且没有记录移动，时间复杂度是o(n)•若文件初态为逆序，则需要n-1趟起泡，每趟进行n-i次排序码的比较，且每次比较都移动三次，比较和移动次数均达到最大∶o(n2)•起泡排序平均时间复杂度为o(n2)②快速排序　　1、基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。　　　　2、实例　　3、java实现按 ctrlc 复制代码package com.sort;//不稳定public class 快速排序 {    public static void main(string[] args) {        int[] a={49,38,65,97,76,13,27,49,78,34,12,64,1,8};        system.out.println(排序之前：);        for (int i = 0; i  a.length; i++) {            system.out.print(a[i]+ );        }        //快速排序        quick(a);        system.out.println();        system.out.println(排序之后：);        for (int i = 0; i  a.length; i++) {            system.out.print(a[i]+ );        }    }    private static void quick(int[] a) {        if(a.length0){            quicksort(a,0,a.length-1);        }    }    private static void quicksort(int[] a, int low, int high) {        if(lowhigh){ //如果不加这个判断递归会无法退出导致堆栈溢出异常            int middle = getmiddle(a,low,high);            quicksort(a, 0, middle-1);            quicksort(a, middle+1, high);        }    }    private static int getmiddle(int[] a, int low, int high) {        int temp = a[low];//基准元素        while(lowhigh){            //找到比基准元素小的元素位置            while(lowhigh  a[high]=temp){                high--;            }            a[low] = a[high];             while(lowhigh  a[low]=temp){                low++;            }            a[high] = a[low];        }        a[low] = temp;        return low;    }}按 ctrlc 复制代码　　4、分析　　快速排序是不稳定的排序。　　快速排序的时间复杂度为o(nlogn)。　　当n较大时使用快排比较好，当序列基本有序时用快排反而不好。四、归并排序　　1、基本思想:归并（merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。　　2、实例　　3、java实现　　4、分析　　归并排序是稳定的排序方法。　　归并排序的时间复杂度为o(nlogn)。　　速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。五、基数排序　　1、基本思想：将所有待比较数（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。　　2、实例　　3、java实现　　4、分析　　基数排序是稳定的排序算法。　　基数排序的时间复杂度为o(d(nr)),d为位数，r为基数。总结：一、稳定性:　 稳定：冒泡排序、插入排序、归并排序和基数排序　　不稳定：选择排序、快速排序、希尔排序、堆排序二、平均时间复杂度　　o(n^2):直接插入排序，简单选择排序，冒泡排序。　　在数据规模较小时（9w内），直接插入排序，简单选择排序差不多。当数据较大时，冒泡排序算法的时间代价最高。性能为o(n^2)的算法基本上是相邻元素进行比较，基本上都是稳定的。　　o(nlogn):快速排序，归并排序，希尔排序，堆排序。　　其中，快排是最好的， 其次是归并和希尔，堆排序在数据量很大时效果明显。三、排序算法的选择　　1.数据规模较小 　　（1）待排序列基本序的情况下，可以选择直接插入排序； 　　（2）对稳定性不作要求宜用简单选择排序，对稳定性有要求宜用插入或冒泡　　2.数据规模不是很大　　（1）完全可以用内存空间，序列杂乱无序，对稳定性没有要求，快速排序，此时要付出log（n）的额外空间。　　（2）序列本身可能有序，对稳定性有要求，空间允许下，宜用归并排序　　3.数据规模很大 　　（1）对稳定性有求，则可考虑归并排序。 　　（2）对稳定性没要求，宜用堆排序　　4.序列初始基本有序（正序），宜用直接插入，冒泡参考资料:　　　　

D0337182C语言程序设计笔记（二）1.第一个c语言程序devc++的使用 　　打开-文件-新建-源代码（注：确保是英文输入状态）　　保存(ctrl+s)-编译-运行（或者-编译并运行）visual c++6.0的使用 　　-打开-新建-工程-win32 console application-输入工程名和选择工程路径-ok 　　-新建-文件-c++ source file-文件名（注：后缀名是.c） 　　-组建-编译（ctrl+f7)-链接(f7)-运行(ctrl+f5) 2.详解第一个程序 1)程序框架本课程中所有的程序都需要这一段直到学习函数之前，我们的代码都只是在这个框架中 2)输出“”里面的内容叫做字符串，printf会把其中的内容原封不动地输出|n表示需要在输出的结果后面换一行  3)暂停如果你的编译器运行后会一闪而过可以在前面加或者 注： 福建省的二级省考用的是wintc编译器需要加,并且位置在return前面或者main结束的那个花括号}。 例如：或者注： 这种写法是不规范的，省考的编译器就支持。建议不要这么写，代码越接近标准，可移植性越好  是不符合任何一个标准的，任何一种标准都反对这种形式，但现实中仍然有些编译器允许这种形式的存在，而有些编译器就明确不允许这种形式，使用这种形式，当你把程序用在不同的编译器间编译的时候，会遇到问题。因此，即使你的编译器允许，也不要这么做。   main()的形式 c89勉强接受，但c99明确表示不允许。4)程序中的错误  - 编译的时候发现的错误所在的地方会以红色的底表示出来（devc++中）  - 具体的错误原因列在下方的窗口里（是英文的）  - c的编译器给出的错误提示往往不那么好“猜”(你鼠标去双击那句话，会定位到提示的那一行，在那一行的上面或者下面一行或者就是那一行有错误)  - 不要去使用中文  3.做点计算  -   - %d说明后面有一个整数要输出在这个位置  - 4.四则运算５.如何在命令行编辑、编译和运行c程序先用vi编辑器创建一个c文件 vi hello.c编译 gcc hello.c  或者gcc hello.c -o hello运行 ./a.out (./hello)6.结构化程序设计方法 基本思想： 　　自顶向下、逐步求精、分而治之 按照结构化的观点 　　可以通过顺序结构、选择（分支）结构、循环结构三种结构去实现 ７.结构化程序设计的原则和步骤 原则：  - 使用语言中的顺序、选择、循环等基本控制结构表示程序逻辑  - 选用的控制结构只准许有一个入口和一个出口  - 程序语句组成容易识别的块，每块只有一个入口和一个出口  - 复杂结构应该用基本控制结构进行组合嵌套来实现  - 尽量避免使用跳转语句(goto,break等语句)  步骤  1）问题分析  2）建立数学模型  3）算法设计  4）程序编码  5）测试  6）建立程序文档８.几个例子(这些代码最好要自己打一遍，而不是简单的复制粘贴)(1).change.c(c99)不支持c99的(2).nihao.c

D0089977OpenCV学习笔记（16）双目测距与三维重建的OpenCV实现问题集锦（一）图像获取与单目定标原文地址：双目测距的基本原理如上图所示，双目测距主要是利用了目标点在左右两幅视图上成像的横向坐标直接存在的差异（即视差）与目标点到成像平面的距离z存在着反比例的关系：z=ft/d。“：在opencv中，f的量纲是像素点，t的量纲由定标板棋盘的实际尺寸和用户输入确定，一般是以毫米为单位（当然为了精度提高也可以设置为0.1毫米量级），d=xl-xr的量纲也是像素点。因此分子分母约去，z的量纲与t相同。”假设目标点在左视图中的坐标为（x,y），在左右视图上形成的视差为d，目标点在以左摄像头光心为原点的世界坐标系中的坐标为（x,y,z），则存在上图所示的变换矩阵q，使得 q*[x y d 1]’ = [x y z w]’。“：为了精确地求得某个点在三维空间里的距离z，我们需要获得的参数有焦距f、视差d、摄像头中心距tx。如果还需要获得x坐标和y坐标的话，那么还需要额外知道左右像平面的坐标系与立体坐标系中原点的偏移cx和cy。其中f, tx, cx和cy可以通过立体标定获得初始，并通过立体校准优化，使得两个摄像头在数学上完全平行放置，并且左右摄像头的cx, cy和f相同(也就是实现图2中左右视图完全平行对准的理想形式)。而立体匹配所做的工作，就是在之前的基础上，求取最后一个变量：视差d(这个d一般需要达到亚像素精度)。从而最终完成求一个点三维坐标所需要的准备工作。在清楚了上述原理之后，我们也就知道了，所有的这几步：标定、校准和匹配，都是围绕着如何更精确地获得f, d, tx, cx和cy而设计的。”一、图像的获取1． 如何打开两个或多个摄像头？可以通过opencv的capture类函数或者结合directshow来实现双摄像头的捕获，具体可见我的读书笔记《》。文中曾提及不能用cvcreatecameracapture 同时读取两个摄像头，不过后来一位研友来信讨论说只要把摄像头指针的创建代码按照摄像头序号降序执行，就可以顺利打开多个摄像头，例如：采用directshow的方式读入时：这样就可以同时采集两个摄像头。我也验证过这种方法确实有效，而且还解决了我遇到的cvsetcaptureproperty调整帧画面大小速度过慢的问题。当摄像头的打开或创建代码按照摄像头序号从0开始以升序编写执行时，使用cvsetcaptureproperty就会出现第一个摄像头（序号为0）的显示窗口为灰色（即无图像）、且程序运行速度缓慢的现象。而改为降序编写执行后，则能正常、实时地显示各摄像头的画面。具体原因有待分析讨论。2． 如何实现多个摄像头帧画面的同步抓取？在单摄像头情况下用 cvqueryframe 即可抓取一帧画面，实际上这个函数是由两个routine组成的：cvgrabframe和cvretrieveframe（详见learning opencv第103页）。cvgrabframe将摄像头帧画面即时复制到内部缓存中，然后通过cvretrieveframe把我们预定义的一个iplimage型空指针指向缓存内的帧数据。注意这时我们并没有真正把帧数据取出来，它还保存在opencv的内部缓存中，下一次读取操作就会被覆盖掉。所以一般我们要另外定义一个iplimage来复制所抓取的帧数据，然后对这个新iplimage进行操作。由上面的解释也可以看出，cvgrabframe的作用就是尽可能快的将摄像头画面数据复制到计算机缓存，这个功能就方便我们实现对多个摄像头的同步抓取，即首先用cvgrabframe依次抓取各个cvcapture*，然后再用cvretrieveframe把帧数据取出来。例如：二、摄像头定标摄像头定标一般都需要一个放在摄像头前的特制的标定参照物（棋盘纸），摄像头获取该物体的图像，并由此计算摄像头的内外参数。标定参照物上的每一个特征点相对于世界坐标系的位置在制作时应精确测定，世界坐标系可选为参照物的物体坐标系。在得到这些已知点在图像上的投影位置后，可计算出摄像头的内外参数。如上图所示，摄像头由于光学透镜的特性使得成像存在着径向畸变，可由三个参数k1,k2,k3确定；由于装配方面的误差，传感器与光学镜头之间并非完全平行，因此成像存在切向畸变，可由两个参数p1,p2确定。单个摄像头的定标主要是计算出摄像头的内参（焦距f和成像原点cx,cy、五个畸变参数（一般只需要计算出k1,k2,p1,p2，对于鱼镜头等径向畸变特别大的才需要计算k3））以及外参（标定物的世界坐标）。opencv中使用的求解焦距和成像原点的算法是基于张正友的方法（），而求解畸变参数是基于brown的方法（）。1． 图像坐标系、摄像头坐标系和世界坐标系的关系摄像头成像几何关系，其中oc点称为摄像头（透镜）的光心，xc轴和yc轴与图像的x轴和y轴平行，zc轴为摄像头的光轴，它与图像平面垂直。光轴与图像平面的交点o1，即为图像坐标系的原点。由点oc与xc、yc、zc轴组成的坐标系称为摄像头坐标系，oco1的距离为摄像头焦距，用f表示。图像坐标系是一个二维平面，又称为像平面，“：实际上就是摄像头的ccd传感器的表面。每个ccd传感器都有一定的尺寸，也有一定的分辨率，这个就确定了毫米与像素点之间的转换关系。举个例子，ccd的尺寸是8mm x 6mm，帧画面的分辨率设置为640x480，那么毫米与像素点之间的转换关系就是80pixel/mm。”设ccd传感器每个像素点的物理大小为dx*dy，相应地，就有 dx=dy=1/80。2． 进行摄像头定标时，棋盘方的实际大小 square_size （默认为 1.0f ）的设置对定标参数是否有影响？“：当然有。在标定时，需要指定一个棋盘方的长度，这个长度(一般以毫米为单位，如果需要更精确可以设为0.1毫米量级)与实际长度相同，标定得出的结果才能用于实际距离测量。一般如果尺寸设定准确的话，通过立体标定得出的translation向量的第一个分量tx的绝对就是左右摄像头的中心距。一般可以用这个来验证立体标定的准确度。比如我设定的棋盘大小为270 (27mm)，最终得出的tx大小就是602.8 (60.28mm)，相当精确。”3． 定标所得的摄像头内参数，即焦距和原点坐标，其数单位都是一致的吗？怎么把焦距数换算为实际的物理量？“：是的，都是以像素为单位。假设像素点的大小为k x l，单位为mm，则fx = f / k， fy = f / (l * sina)， a一般假设为 90°，是指摄像头坐标系的偏斜度（就是镜头坐标和ccd是否垂直）。摄像头矩阵（内参）的目的是把图像的点从图像坐标转换成实际物理的三维坐标。因此其中的fx, fy, cx, cy 都是使用类上面的纲量。同样，q 中的变量 f，cx, cy 也应该是一样的。”4． 棋盘图像数目应该取多少对摄像头定标比较适宜？opencv中文论坛上piao的帖子《》中指出影响摄像头定标结果的准确性和稳定性的因素主要有三个：（1） 标定板所在平面与成像平面(image plane)之间的夹角；（2） 标定时拍摄的图片数目（棋盘图像数目）；（3） 图像上角点提取的不准确。感觉opencv1.2以后对图像角点的提取准确度是比较高的，cvfindchessboardcorners 和 cvfindcornersubpix结合可以获得很好的角点检测效果（hqhuang1在《》中给出了相关的应用范例）。因此，影响定标结果较大的就是标定板与镜头的夹角和棋盘图像数目，在实际定标过程中，我感觉棋盘图像数目应该大于20张，每成功检测一次完整的棋盘角点就要变换一下标定板的姿态（包括角度、距离）。5． 单目定标函数cvcalibratecamera2采用怎样的 flags 比较合适？由于一般镜头只需要计算k1,k2,p1,p2四个参数，所以我们首先要设置 cv_calib_fix_k3；其次，如果所用的摄像头不是高端的、切向畸变系数非常少的，则不要设置 cv_calib_zero_tangent_dist，否则单目校正误差会很大；如果事先知道摄像头内参的大概数，并且cvcalibratecamera2函数的第五个参数intrinsic_matrix非空，则也可设置 cv_calib_use_intrinsic_guess ，以输入的intrinsic_matrix为初始估计来加快内参的计算；其它的 flag 一般都不需要设置，对单目定标的影响不大。p.s. 使用opencv进行摄像机定标虽然方便，但是定标结果往往不够准确和稳定，最好是使用来进行定标，再将定标结果取回来用于立体匹配和视差计算。工具箱的使用有图文并茂的详细说明，此外，有两篇博文也进行了不错的总结，推荐阅读：（1）（2）.

D0403281SpringMVC 文件上传配置，多文件上传，使用的MultipartFile基本的springmvc的搭建在我的上一篇文章里已经写过了，这篇文章主要说明一下如何使用springmvc进行表单上的文件上传以及多个文件同时上传的步骤springmvc 基础教程 框架分析：springmvc 基础教程 简单入门实例：文件上传项目的源码下载地址：一、配置文件：springmvc 用的是 的multipartfile来进行文件上传 所以我们首先要配置multipartresolver:用于处理表单中的file[html] !--配置multipartresolver用于文件上传使用spring的commosmultipartresolver--beans:beanid=multipartresolverclass=org.springframework.web.multipart.commons.commonsmultipartresolverp:defaultencoding=utf-8p:maxuploadsize=5400000p:uploadtempdir=fileupload/temp/beans:bean其中属性详解：defaultencoding=utf-8 是请求的编码式，默认为iso-8859-1maxuploadsize=5400000 是上传文件的大小，单位为字节uploadtempdir=fileupload/temp 为上传文件的临时路径二、创建一个简单的上传表单：[html] bodyh2文件上传实例/h2formaction=fileupload.htmlmethod=postenctype=multipart/form-data选择文件:inputtype=filename=fileinputtype=submitvalue=提交/form/body注意要在form标签中加上enctype=multipart/form-data表示该表单是要处理文件的,这是最基本的东西，很多人会忘记然而当上传出错后则去找程序的错误，却忘了这一点三、编写上传控制类1、创建一个控制类: fileuploadcontroller和一个返回结果的页面list.jsp2、编写提交表单的action:[java] //通过spring的autowired注解获取spring默认配置的request@autowiredprivatehttpservletrequestrequest;/****上传文件用@requestparam注解来指定表单上的file为multipartfile**@paramfile*@return*/@requestmapping(fileupload)publicstringfileupload(@requestparam(file)multipartfilefile){//判断文件是否为空if(!file.isempty()){try{//文件保存路径stringfilepath=request.getsession().getservletcontext().getrealpath(/)upload/file.getoriginalfilename();//转存文件file.transferto(newfile(filepath));}catch(exceptione){e.printstacktrace();}}//重定向returnredirect:/list.html;}/****读取上传文件中得所有文件并返回**@return*/@requestmapping(list)publicmodelandviewlist(){stringfilepath=request.getsession().getservletcontext().getrealpath(/)upload/;modelandviewmav=newmodelandview(list);fileuploaddest=newfile(filepath);string[]filenames=uploaddest.list();for(inti=0;ifilenames.length;i){//打印出文件名system.out.println(filenames[i]);}returnmav;}3、使用springmvc注解requestparam来指定表单中的file参数；4、指定一个用于保存文件的web项目路径5、通过multipartfile的transferto(file dest)这个方法来转存文件到指定的路径。到此基本的文件上传就结束了。multipartfile类常用的一些方法：string getcontenttype()//获取文件mime类型inputstream getinputstream()//后去文件流string getname() //获取表单中文件组件的名字string getoriginalfilename() //获取上传文件的原名long getsize()//获取文件的字节大小，单位byteboolean isempty() //是否为空void transferto(file dest) //保存到一个目标文件中。四、多文件上传。多文件上传其实很简单，和上传其他相同的参数如checkbox一样，表单中使用相同的名称，然后action中将multipartfile参数类定义为数组就可以。接下来实现：1、创建一个上传多文件的表单：[html] bodyh2上传多个文件实例/h2formaction=filesupload.htmlmethod=postenctype=multipart/form-datap选择文件:inputtype=filename=filesp选择文件:inputtype=filename=filesp选择文件:inputtype=filename=filespinputtype=submitvalue=提交/form/body2、编写处理表单的action，将原来保存文件的方法单独写一个方法出来方便共用：[java] /****保存文件*@paramfile*@return*/privatebooleansavefile(multipartfilefile){//判断文件是否为空if(!file.isempty()){try{//文件保存路径stringfilepath=request.getsession().getservletcontext().getrealpath(/)upload/file.getoriginalfilename();//转存文件file.transferto(newfile(filepath));returntrue;}catch(exceptione){e.printstacktrace();}}returnfalse;}3、编写action:@requestmapping(filesupload)publicstringfilesupload(@requestparam(files)multipartfile[]files){//判断file数组不能为空并且长度大于0if(files!=nullfiles.length0){//循环获取file数组中得文件for(inti=0;ifiles.length;i){multipartfilefile=files[i];//保存文件savefile(file);}}//重定向returnredirect:/list.html;}最后运行项目上传文件:

D0197749Masonry介绍与使用实践(快速上手Autolayout) 来自里脊串的开发随笔前言以上是纯手写代码所经历的关于页面布局的三个时期在iphone1-iphone3gs时代 window的size固定为(320,480) 我们只需要简单计算一下相对位置就好了在iphone4-iphone4s时代 苹果推出了retina屏 但是给了码农们非常大的福利:window的size不变在iphone5-iphone5s时代 window的size变了(320,568) 这时派上了用场(为啥这时候不用autolayout? 因为还要支持ios5呗) 简单的适配一下即可在iphone6时代 window的width也发生了变化(相对5和5s的屏幕比例没有变化) 终于是时候抛弃改用autolayout了(不用支持ios5了 相对于屏幕适配的多样性来说也已经过时了)那如何快速的上手autolayout呢? 说实话 当年ios6推出的同时新增了autolayout的特性 我看了一下官方文档和demo 就立马抛弃到一边了 因为实在过于的(有过经验的朋友肯定有同感)直到iphone6发布之后 我知道使用autolayout势在必行了 这时想起了以前在浏览github看到过的一个第三方库masonry 在花了几个小时的研究使用后 我就将autolayout掌握了() 这就是我为什么要写下这篇文章来推荐它的原因介绍masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性我们先来看一段官方的sample code来认识一下masonry看到block里面的那句话:通过链式的自然语言 就把view1给autolayout好了 是不是简单易懂?使用看一下masonry支持哪一些属性这些属性与nslayoutattrubute的对照表如下masonrynsautolayout说明leftnslayoutattributeleft左侧topnslayoutattributetop上侧rightnslayoutattributeright右侧bottomnslayoutattributebottom下侧leadingnslayoutattributeleading首部trailingnslayoutattributetrailing尾部widthnslayoutattributewidth宽heightnslayoutattributeheight高centerxnslayoutattributecenterx横向中点centerynslayoutattributecentery纵向中点baselinenslayoutattributebaseline文本基线其中leading与left trailing与right 在正常情况下是等价的 但是当一些布局是从右至左时(比如阿拉伯文?没有类的经验) 则会对调 换句话说就是基本可以不理不用 用left和right就好了在ios8发布后 又新增了一堆奇奇怪怪的属性(有兴趣的朋友可以去瞅瞅) masonry暂时还不支持(不过你要支持ios6,ios7 就没必要去管那么多了)在讲实例之前 先介绍一个macro快速的定义一个weakself 当然是用于block里面啦 下面进入正题(为了方便 我们测试的superview都是一个size为(300,300)的uiview)下面 通过一些简单的实例来简单介绍如何的使用masonry:1. [基础]居中显示一个view代码效果使用我之间写的可以看到superview已经按照我们预期居中并且设置成了适当的大小那么先看看这几行代码这里有两个问题要分解一下首先在masonry中能够添加autolayout约束有三个函数其次 equalto 和 mas_equalto的区别在哪里呢? 其实 mas_equalto是一个macro可以看到 mas_equalto只是对其参数进行了一个box操作(装箱) masboxvalue的定义具体可以看看源代码 太长就不贴出来了所支持的类型 除了nsnumber支持的那些数类型之外 就只支持介绍完这几个问题 我们就继续往下了 ps:刚才定义的sv会成为我们接下来所有sample的superview2. [初级]让一个view略小于其superview(边距为10)代码效果可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事那么为什么bottom和right里的offset是负数呢? 因为这里计算的是绝对的数 计算的bottom需要小鱼sv的底部高度 所以要-10 同理用于right这里有意思的地方是和其实这两个函数什么事情都没做但是用在这种链式语法中 就非常的巧妙和易懂 不得不佩服作者的心思(虽然我现在基本都会省略)3. [初级]让两个高度为150的view垂直居中且等宽且等间隔排列 间隔为10(自动计算其宽度)代码效果这里我们在两个子view之间互相设置的约束 可以看到他们的宽度在约束下自动的被计算出来了4. [中级]在uiscrollview顺序排列一些view并自动计算contentsize头部效果尾部效果从scrollview的scrollindicator可以看出 scrollview的内部已如我们所想排列好了这里的关键就在于container这个view起到了一个中间层的作用 能够自动的计算uiscrollview的contentsize5. [高级]横向或者纵向等间隙的排列一组view很遗憾 autolayout并没有直接提供等间隙排列的方法(masonry的官方demo中也没有对应的案例) 但是参考案例3 我们可以通过一个小技巧来实现这个目的 为此我写了一个category简单的来测试一下代码效果perfect! 简洁明了的达到了我们所要的效果这里所用的技巧就是 使用空白的占位view来填充我们目标view的旁边 这点通过图上的空白标注可以看出来小结通过以上5个案例 我觉得已经把masonry的常用功能介绍得差不多了 如果你觉得意犹未尽呢 请下载官方的demo来学习总而言之 masonry是一个非常优秀的autolayout库 能够节省大量的开发和学习时间 尤其适合我这种纯代码的ioser 在iphone6发布后引发的适配潮中 masonry一定可以助你一臂之力 :)

D0620017Android的Socket通信编程实例android手机的应用，除了它的手机功能之外，另外一个吸引人的地方在于它的开放性，这一点iphone无法比拟，至少iphone太多商业化气息。android为我们开启另一扇交流之窗，而要实现交流，socket通信必不可少。java在socket通信方面上已经有了很好的范例，我只是抛砖引玉，将其引入到android之中，疏漏之处在所难免，很多地方也得深思与考量，高手不必拍砖，可跳过此文。下面，用敲门的方式演示android如何实现套接字的通信。服务器程序服务器程序需要在pc上运行，该程序比较的简单，因此不需要建立android项目，直接定义一个java类，并且运行该类即可。它仅仅建立serversocket监听，并使用socket获取输入输出流。import java.io.ioexception;  import java.io.outputstream; import java.net.serversocket; import java.net.socket;public class simpleserver { /** * @param args * @throws ioexception  */ public static void main(string[] args) throws ioexception { // todo auto-generated method stub //创建一个serversocket,用于监听客户端socket的连接请求 serversocket ss=new serversocket(30000); //采用循环不断接受来自客户端的请求,服务器端也对应产生一个socket while(true){ socket s=ss.accept(); outputstream os=s.getoutputstream(); os.write(您好，您收到了服务器的新年祝福！n.getbytes(utf-8)); os.close(); s.close(); } }}客户端程序package my.learn.tcp;import java.io.bufferedreader;import java.io.ioexception;import java.io.inputstreamreader;import java.net.socket;import java.net.unknownhostexception;import android.app.activity;import android.os.bundle;import android.util.log;import android.widget.edittext;public class simpleclient extends activity { private edittext show; @override protected void oncreate(bundle savedinstancestate) { // todo auto-generated method stub super.oncreate(savedinstancestate); setcontentview(r.layout.main); show = (edittext) findviewbyid(r.id.show); try { socket socket = new socket(自己计算机的ip地址, 30000); //设置10秒之后即认为是超时 socket.setsotimeout(10000); bufferedreader br = new bufferedreader(new inputstreamreader( socket.getinputstream())); string line = br.readline(); show.settext(来自服务器的数据：line); br.close(); socket.close(); } catch (unknownhostexception e) { // todo auto-generated catch block log.e(unknownhost, 来自服务器的数据); e.printstacktrace(); } catch (ioexception e) { log.e(ioexception, 来自服务器的数据); // todo auto-generated catch block e.printstacktrace(); } }}最后不要忘记在manifest.xml文件当中，需要对互联网的访问进行授权。uses-permission android:name=android.permission.internet/

D0274076拿工资不仅仅是让你写代码的这是我对团队每个新进员工说的第一件事情。这句话的意思是，我并不关心你是如何快速完成任务的，哪怕代码很差，只要它像救生艇通气门一样管用就行。这句话也是我最喜欢的座右铭之一。这个说法其实很合理：我们的工作是思考客户提出的问题，然后制定解决方案。思考第一，代码第二，公司请我们的最终目的不是，而是想出解决方案。话粗理不粗。付你薪水不是让你来思考的，也不是让你来写代码的，你的目的是交付产品。如果不能交付有效的产品给客户，那么你的知识，技能，态度，以及所有能让人成为高效程序员的特性又有什么意义呢？！没有客户会说：“嗯，如果能用空代替tab键表示缩进，那代码将更具可读性。”也没有客户会要求我们使用单向散列存储的密码，事实上他们可能听都没听说过。没有客户会强求我们想出所有可能的架构和平台，然后择优选用。更加没有客户会问及他们的项目使用的是什么代码标准。客户不在乎代码，也不在乎架构，更加不在乎整个系统是否臃肿不堪。他们想要的就是解决他们的问题。真正的难点在于权衡以下这两个极端：我们的工作就是写代码，亦或是认为，代码和产品这两个条件永远无法同时满足。下面让我们认识两位新手程序员——sam和ted。ps：如有雷同，纯属巧合。sam是一名从刚从当地一所大学毕业的新员工，是个标标准准的学霸。她的面试和fizzbuzz测试表现都非常出色，现在她正式开始她的第一天程序员生涯工作（被聘用了！）。你，作为项目负责人，指派给她第一个任务。因为她才刚开始，所以任务并不难，你（作为一名有经验的开发人员）觉得大概一小时时间就能搞定，不过，你基于保守估计，认为她可能需要用一天的时间。最终她花了一个星期时间！从第二天开始，每次检查的时候，她都信誓旦旦地说一切进展顺利，代码会写得非常完美。最后终于完成了，果然如她所说的那样：代码完美得像艺术品。但是，请注意，她花了一个星期的时间才完成了这项本应该不超过一天的任务。现在，来说说ted。ted和sam同一天被录用。他的面试也很顺利，尽管他完成问题的速度非常快。你也给了ted一个相对简单的任务：大概需要一天时间。但是他只花了一小时！在你中午的休息时间，ted就噌噌噌跑过来交任务了——瞧那骄傲自得沾沾自喜的样子，仿佛在一个劲说“求表扬，求给赞！”但是一看他的代码，就只能呵呵了：很多复制粘贴来的代码片段，乱七八糟的函数命名，组织混乱，雾里看花的解释，等等等等，就像一锅大杂烩一样，你不认识我我也不认识你。你的团队更属意谁呢，sam还是ted？都不是。这两个实际上都不能提供真正的产品？他们一样糟糕：一个思考得太多，另一个则思考得太少。所以，谨记这一点，付你薪水不仅仅是让你来写代码的，也不是仅仅只需要思考，你还需要开发出能够解决问题的产品。对此，你的看法呢？欢迎各抒己见。免费领取原创光盘/《》精要版，详情咨询官网客服：

D0627618出 千 赌 具【加威-信13535353835】出 千 赌 具出 千 赌 具看出请加【“微-xin”:135-353-53835】，-千视-频出 千 赌 具欢迎您的给力支持。 微-xin号：13535353835 加了看演示视-频 ================================================================== 目前提供各种免费教学，技巧的实战实用绝技！欢迎爱好者自带，由本部大师根据不同的要求免费为大家一一表演，不满意不学，满意后在学！出 千 赌 具本师根据不同学员的要求传授不同的技术！本团队承诺：技术包教包会！在此。我们希望您在桌上娱乐亦或是竞技的时候，总是赢得漂亮，玩 的开心，祝您生活更加美满。 ================================================================== 一般连升几级不过这种升级时候感悟和感受却是决然不同循序渐进稳扎稳打才是王道每一步要有每一步感悟如此积累才是巅峰前世那般催猪一样飞升你觉得很爽么笨蛋若不是本大人为你压制着出 千 赌 具你这时候也早已上去了前世为何你到不了巅峰就是因为你缺乏了这一步一步感悟一口吃成个胖子唯出 千 赌 具一结果就是把人撑死明白么笨蛋脑海中一个狂傲声音非常不屑一顾又带着一种恨铁不成钢口气说道出 千 赌 具一,     

D0652053澳 门 赌 具【加威-信13535353835】澳 门 赌 具澳 门 赌 具看出请加【“微-xin”:135-353-53835】，-千视-频澳 门 赌 具欢迎您的给力支持。 微-xin号：13535353835 加了看演示视-频 ================================================================== 目前提供各种免费教学，技巧的实战实用绝技！欢迎爱好者自带，由本部大师根据不同的要求免费为大家一一表演，不满意不学，满意后在学！澳 门 赌 具本师根据不同学员的要求传授不同的技术！本团队承诺：技术包教包会！在此。我们希望您在桌上娱乐亦或是竞技的时候，总是赢得漂亮，玩 的开心，祝您生活更加美满。 ================================================================== 看到几个小白脸摆姿势饭馆付账还要装腔作势拿出一副视钱财如粪土欠揍样子老子就以为他们实在是太装了但直到今天才知道什么叫做真正装这样水平真该当那帮小兔澳 门 赌 具崽子祖师爷一阵无语我说是实话好吧记得前世时候可不止是只升一级而已经常是坐澳 门 赌 具着火箭一般连升几级不过这种升级时候感悟和感受却是决然不同循序渐进稳扎稳打才澳 门 赌 具是王,     

D0555299单 人 操 作 袖 口 镜 头【加威-信13535353835】单 人 操 作 袖 口 镜 头单 人 操 作 袖 口 镜 头看出请加【“微-xin”:135-353-53835】，-千视-频单 人 操 作 袖 口 镜 头欢迎您的给力支持。 微-xin号：13535353835 加了看演示视-频 ================================================================== 目前提供各种免费教学，技巧的实战实用绝技！欢迎爱好者自带，由本部大师根据不同的要求免费为大家一一表演，不满意不学，满意后在学！单 人 操 作 袖 口 镜 头本师根据不同学员的要求传授不同的技术！本团队承诺：技术包教包会！在此。我们希望您在桌上娱乐亦或是竞技的时候，总是赢得漂亮，玩 的开心，祝您生活更加美满。 ================================================================== 何一个人才都不能放过更何况是这样足可称得上是可怕人才铁补天神色转为冷漠低声对身边一个青衣人道传令武狂云让他到铁云城一趟告诉他若是不能解释清楚杜神医遇袭之事他身体就不用来了只把脑袋送过来吧武狂云铁云帝国铁血战骑大统领也单 人 操 作 袖 口 镜 头是铁云西南军方与大赵边境一员悍将名列大陆名将排行榜第十位这个排名大陆十位名将排行榜之中虽然只是末尾但却绝不是单纯单 人 操 作 袖 口 镜 头作战勇敢就能得到铁补天此刻提起武狂云很显然从这件事时机和风已经断定这件事必然是武狂云所做无疑青衣人答应一声单 人 操 作 袖 口 镜 头忍不,     

D0457248n!阶乘末尾有多少个零0题目： 初阶：1*2*3*……*100 求结果末尾有多少个零。 进阶: n的阶乘末尾有多少个0分析： 一般类似的题目都会蕴含某种规律或简便方法的阶乘末尾一个零表示一个进位，则相当于乘以10而10 是由2*5所得，在1~100当中，可以产生10的有：0 2 4 5 6 8 结尾的数字，显然2是确定的，因为4、6、8当中都含有因子2，所以都可看当是2，那么关键在于5的数量了那么该问题的实质是要求出1~100含有多少个5由特殊推广到一般的论证过程可得：         1、 每隔5个，会产生一个0，比如 5， 10 ，15，20.。。         2 、每隔 5×5 个会多产生出一个0，比如 25，50，75，100          3 、每隔 5×5×5 会多出一个0，比如125.所以100！末尾有多少个零为：100/5+100/25=20+4=24那么1000！末尾有多少个零呢？同理得：  1000/5+1000/25+1000/125=200+40+8=248 到此，问题解决了，但我们在学习过程中应当学会发散思维、举一反三。接着，请问n！的末尾有多少个零呢？ 其实 也是同理的         n/5+n/25+…… 如计算 2009! 的末尾有多少个0:2009/5 = 401 1~2009之间有 401 个数是 5 的倍数(余数省略).401/5 = 80 1~2009 之间有 80 个数是 25 的倍数.80/5 = 16 1~2009 之间有 16 个数是 125 的倍数.  16/5 = 3 1~2009 之间有 3个数是 625 的倍数.      3/5 = 0 1~2009 之间有 0 个数是 3125 的倍数. 所以, 2009！ 的末尾有 401 + 80 + 16 + 3 = 500 个0.代码：此题扩展：求扩展n！的二进制表示中最低位1中的位置。相当于求质因数的2的个数。原理是： 假如你把1   ×   2   ×３×   4   ×……×n中每一个因数分解质因数，结果就像： 1   ×   2   ×   3   ×   (2   ×   2)   ×   5   ×   (2   ×   3)   ×   7   ×   (2   ×   2   ×2)   ×……   10进制数结尾的每一个0都表示有一个因数10存在——任何进制都一样，对于一个m进制的数，让结尾多一个0就等价于乘以m。 10可以分解为2   ×   5——因此只有质数2和5相乘能产生0，别的任何两个质数相乘都不能产生0，而且2，5相乘只产生一个0。 所以，分解后的整个因数式中有多少对(2,   5)，结果中就有多少个0，而分解的结果中，2的个数显然是多于5的，因此，有多少个5，就有多少个(2,   5)对。 所以，讨论1000的阶乘结尾有几个0的问题，就被转换成了1到1000所有这些数的质因数分解式有多少个5的问题。  参考资料：

D0279074Android中layout过程详解 相比较onmeasure ，layout过程要简单多了，正如layout的中文意思“布局”中表达的一样，layout的过程就是确定view在屏幕上显示的具体位置，在代码中就是设置其成员变量mleft，mtop，mright，mbottom的，这几个构成的矩形区域就是该view显示的位置，不过这里的具体位置都是相对与父视图的位置。 与onmeasure过程类，viewgroup在onlayout函数中通过调用其children的layout函数来设置子视图相对与父视图中的位置，具体位置由函数layout的参数决定，当我们继承viewgroup时必须重载onlayout函数（viewgroup中onlayout是abstract修饰），然而onmeasure并不要求必须重载，因为相对与layout来说，measure过程并不是必须的，具体后面会提到。首先我们来看下view.java中函数layout和onlayout的源码：函数layout的主体过程还是很容易理解的，首先通过调用setframe函数来对4个成员变量（mleft，mtop，mright，mbottom）赋，然后回调onlayout函数，最后回调所有注册过的listener的onlayoutchange函数。对于view来说，onlayout只是一个空实现，一般情况下我们也不需要重载该函数：接着我们来看下viewgroup.java中layout的源码：super.layout(l, t, r, b)调用的即是view.java中的layout函数，相比之下viewgroup增加了layouttransition的处理，layouttransition是用于处理viewgroup增加和删除子视图的动画效果，也就是说如果当前viewgroup未添加layouttransition动画，或者layouttransition动画此刻并未运行，那么调用super.layout(l, t, r, b)，继而调用到viewgroup中的onlayout，否则将mlayoutsuppressed设置为true，等待动画完成时再调用requestlayout()。   上面super.layout(l, t, r, b)会调用到viewgroup.java中onlayout，其源码实现如下：和前面view.java中的onlayout实现相比，唯一的差别就是viewgroup中多了关键字abstract的修饰，也就是说viewgroup类只能用来被继承，无法实例化，并且其子类必须重载onlayout函数，而重载onlayout的目的就是安排其children在父视图的具体位置。重载onlayout通常做法就是起一个for循环调用每一个子视图的layout(l, t, r, b)函数，传入不同的参数l, t, r, b来确定每个子视图在父视图中的显示位置。   那layout(l, t, r, b)中的4个参数l, t, r, b如何来确定呢？联想到之前的measure过程，measure过程的最终结果就是确定了每个视图的mmeasuredwidth和mmeasuredheight，这两个参数可以简单理解为视图期望在屏幕上显示的宽和高，而这两个参数为layout过程提供了一个很重要的依据（但不是必须的），为了说明这个过程，我们来看下linearlayout的layout过程：从setchildframe可以看到linearlayout中的子视图的右边界等于left  width，下边界等于topheight，也就是说在linearlayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考。   layout过程必须要依靠measure计算出来的mmeasuredwidth和mmeasuredheight来决定视图的显示大小吗？事实并非如此，layout过程中的4个参数l, t, r, b完全可以由视图设计者任意指定，而最终视图的布局位置和大小完全由这4个参数决定，measure过程得到的mmeasuredwidth和mmeasuredheight提供了视图大小的，但我们完全可以不使用这两个，可见measure过程并不是必须的。\\   说到这里就不得不提getwidth()、getheight()和getmeasuredwidth()、getmeasuredheight()这两对函数之间的区别，getmeasuredwidth()、getmeasuredheight()返回的是measure过程得到的mmeasuredwidth和mmeasuredheight的，而getwidth()和getheight()返回的是mright - mleft和mbottom - mtop的，看view.java中的源码便一清二楚了：这也解释了为什么有些情况下getwidth()和getmeasuredwidth()以及getheight()和getmeasuredheight()会得到不同的。   总结：整个layout过程比较容易理解，一般情况下layout过程会参考measure过程中计算得到的mmeasuredwidth和mmeasuredheight来安排子视图在父视图中显示的位置，但这不是必须的，measure过程得到的结果可能完全没有实际用处，特别是对于一些自定义的viewgroup，其子视图的个数、位置和大小都是固定的，这时候我们可以忽略整个measure过程，只在layout函数中传入的4个参数来安排每个子视图的具体位置。

D0812051用for循环来删除ArrayList集合中的所有元素所遇到的问题问题：arraylist集合中已经有了一些元素，现在想把这些元素都给删了，用for循环，结果发现元素中的序号为偶数的元素都没删除成功。 arraylist list = new arraylist();         // 任意添加一些元素在集合中         for (int i = 1; i = 10; i++) {             list.add(i);         }         // 现在想删除集合中的所有元素，用for循环         for (int i = 0; i  list.size(); i++) {             list.remove(i);         }         // 输出看看是否全部删除完整         for (object obj : list) {             system.out.println(obj);         }         运行结果为： 2 4 6 8 10 原因：remove()方法在删除时以后，就会从左到右移动集合中的元素，所有造成序号为偶数个的集合元素给保留了下来。 解决： //用一个while循环来删除         while (!list.isempty()) {             for (int i = 0; i  list.size(); i++) {                 list.remove(i);             }             // 再次输出看看是否全部删除完整         for (object obj : list) {             system.out.println(obj);         }         结果显示都删完了！ 当然还有一个比较简便的方法：       list.removeall(list);       //一句话搞定

D0078254Laravel Eloquent ORM--整理介绍  laravel 的 eloquent orm 提供了漂亮、简洁的 activerecord 实现来和数据库的互动。 每个数据库表会和一个对应的「模型」互动。    在开始之前，记得把 config/database.php 里的数据库连接配置好。基本用法  我们先从建立一个 eloquent 模型开始。模型通常放在 app 目录下，但是您可以将它们放在任何地方，只要能通过 composer.json 自动载入。所有的 eloquent 模型都继承于 illuminate\database\eloquent\model .例如我放在app/models下，则在composer.json中的配置如下：1. 创建[模型]手动创建在app/models下新建文件logo.php命令创建命令创建的好处是：同时会在database/migrations 下生成对应的数据库迁移文件。   注意我们并没有告诉 eloquent user 模型会使用哪个数据库表。若没有特别指定，系统会默认自动对应名称为「类名称的小写复数形态」的数据库表。所以，在上面的例子中， eloquent 会假设 user 模型将把数据存在 users 数据库表。您也可以在类中定义 table 属性自定义要对应的数据库表。    注意： eloquent 也会假设每个数据库表都有一个字段名称为 id 的主键。您可以在类里定义 primarykey 属性来重写。同样的，您也可以定义 connection 属性，指定模型连接到指定的数据库连接。   定义好模型之后，您就可以从数据库表新增及获取数据了。注意在默认情况下，在数据库表里需要有 updated_at 和 created_at 两个字段。如果您不想设定或自动更新这两个字段，则将类里的 $timestamps 属性设为 false即可。    2. 使用[模型]使用模型的方法  取出所有记录：    根据主键取出一条数据：     拆分查询：传到方法里的第一个参数表示每次「拆分」要取出的数据数量。第二个参数的闭合函数会在每次取出数据时被调用。其他方法就不一一列举了，可以访问：[eloquent orm]()如果没办法使用流畅接口产生出查询语句，也可以使用 whereraw 方法：软删除  通过软删除方式删除了一个模型后，模型中的数据并不是真的从数据库被移除。而是会设定 deleted_at时间戳。要让模型使用软删除功能，只要在模型类里加入 softdeletingtrait 即可：  要加入 deleted_at 字段到数据库表，可以在迁移文件里使用 softdeletes 方法：  现在当您使用模型调用 delete 方法时， deleted_at字段会被更新成现在的时间戳。在查询使用软删除功能的模型时，被「删除」的模型数据不会出现在查询结果里。普通查询方法只能查询到deleted_at为null的数据，也就是未被删除/有效的数据。要强制让已被软删除的模型数据出现在查询结果里，在查询时使用 withtrashed 方法：如果您只想查询被软删除的模型数据，可以使用 onlytrashed 方法：要把被软删除的模型数据恢复，使用 restore 方法：您也可以结合查询语句使用 restore ：如果想要真的从模型数据库删除，使用 forcedelete 方法：要确认模型是否被软删除了，可以使用 trashed 方法：范围查询定义范围查询  范围查询可以让您轻松的重复利用模型的查询逻辑。要设定范围查询，只要定义有 scope 前缀的模型方法：使用范围查询动态范围查询  有时您可能想要定义可接受参数的范围查询方法。只要把参数加到方法里：  然后把参数值传到范围查询方法调用里：3. 关联一对一定义一对一关联  一对一关联是很基本的关联。例如一个 user 模型会对应到一个 phone 。 在 eloquent 里可以像下面这样定义关联：  传到 hasone 方法里的第一个参数是关联模型的类名称。定义好关联之后，就可以使用 eloquent 的动态属性取得关联对象：  sql 会执行如下语句：注意， eloquent 假设对应的关联模型数据库表里，外键名称是基于模型名称。在这个例子里，默认 phone 模型数据库表会以 user_id 作为外键。如果想要更改这个默认，可以传入第二个参数到 hasone 方法里。更进一步，您可以传入第三个参数，指定关联的外键要对应到本身的哪个字段：定义相对的关联  要在 phone 模型里定义相对的关联，可以使用 belongsto 方法：  在上面的例子里， eloquent 默认会使用 phones 数据库表的 user_id 字段查询关联。如果想要自己指定外键字段，可以在 belongsto 方法里传入第二个参数：  除此之外，也可以传入第三个参数指定要参照上层数据库表的哪个字段：一对多定义一对多关联  一对多关联的例子如，一篇 blog 文章可能「有很多」评论。可以像这样定义关联：  现在可以经由动态属性取得文章的评论：  如果需要增加更多条件限制，可以在调用 comments 方法后面通过链式查询条件方法：  同样的，您可以传入第二个参数到 hasmany 方法更改默认的外键名称。以及，如同 hasone 关联，可以指定本身的对应字段：定义相对的关联  要在 comment 模型定义相对应的关联，可使用 belongsto 方法：多对多定义多对多关联  多对多关联更为复杂。这种关联的例子如，一个用户（ user ）可能用有很多身份（ role ），而一种身份可能很多用户都有。例如很多用户都是「管理者」。多对多关联需要用到三个数据库表： users ， roles ，和 role_user 。 role_user 枢纽表命名是以相关联的两个模型数据库表，依照字母顺序命名，枢纽表里面应该要有 user_id 和 role_id 字段。    可以使用 belongstomany 方法定义多对多关系：  现在我们可以从 user 模型取得 roles：  如果不想使用默认的枢纽数据库表命名方式，可以传递数据库表名称作为 belongstomany 方法的第二个参数：  也可以更改默认的关联字段名称：has many through 远层一对多关联  「远层一对多关联」提供了方便简短的方法，可以经由多层间的关联取得远层的关联。例如，一个 country 模型可能通过 users 关联到很多 posts 模型。 数据库表间的关系可能看起来如下：  虽然 posts 数据库表本身没有 country_id 字段，但 hasmanythrough 方法让我们可以使用 $country-posts 取得 country 的 posts。我们可以定义以下关联：  如果想要手动指定关联的字段名称，可以传入第三和第四个参数到方法里：关联查询根据关联条件查询  在取得模型数据时，您可能想要以关联模型作为查询限制。例如，您可能想要取得所有「至少有一篇评论」的blog 文章。可以使用 has 方法达成目的：  也可以指定运算符和数量：  也可以使用”点号”的形式来获取嵌套的 has 声明：  如果想要更进阶的用法，可以使用 wherehas 和 orwherehas 方法，在 has 查询里设置 “where” 条件 ：动态属性  eloquent 可以经由动态属性取得关联对象。 eloquent 会自动进行关联查询，而且会很聪明的知道应该要使用 get（用在一对多关联）或是 first （用在一对一关联）方法。可以经由和「关联方法名称相同」的动态属性取得对象。例如，如下面的模型对象 $phone：  您可以不用像下面这样打印用户的 email ：    而可以简写如下： 若取得的是许多关联对象，会返回 illuminate\database\eloquent\collection 对象。预载入  预载入是用来减少 n + 1 查询问题。例如，一个 book 模型数据会关联到一个 author 。关联会像下面这样定义：  现在考虑下面的代码：  上面的循环会执行一次查询取回所有数据库表上的书籍，然而每本书籍都会执行一次查询取得作者。所以若我们有 25 本书，就会进行 26次查询。    很幸运地，我们可以使用预载入大量减少查询次数。使用 with 方法指定想要预载入的关联对象：  现在，上面的循环总共只会执行两次查询：  使用预载入可以大大提高程序的性能。    当然，也可以同时载入多种关联：预载入条件限制  有时您可能想要预载入关联，同时也想要指定载入时的查询限制。下面有一个例子：  上面的例子里，我们预载入了 user 的 posts 关联，并限制条件为 post 的 title 字段需包含 “first” 。    当然，预载入的闭合函数里不一定只能加上条件限制，也可以加上排序：新增关联模型附加一个关联模型  您常常会需要加入新的关联模型。例如新增一个 comment 到 post 。除了手动设定模型的 post_id 外键，   也可以从上层的 post 模型新增关联的 comment ：  上面的例子里，新增的 comment 模型中 post_id 字段会被自动设定。    如果想要同时新增很多关联模型：从属关联模型 ( belongs to )  要更新 belongsto 关联时，可以使用 associate 方法。这个方法会设定子模型的外键：新增多对多关联模型 ( many to many )  您也可以新增多对多的关联模型。让我们继续使用 user 和 role 模型作为例子。我们可以使用 attach 方法简单地把 roles 附加给一个 user：附加多对多模型  也可以传入要存在枢纽表中的属性数组：  当然，有 attach 方法就会有相反的 detach 方法：  attach 和 detach 都可以接受id数组作为参数：使用 sync 方法同时附加一个以上多对多关联  您也可以使用 sync 方法附加关联模型。 sync 方法会把根据 id 数组把关联存到枢纽表。附加完关联后，枢纽表里的模型只会关联到 id 数组里的 id ：sync 时在枢纽表加入额外数据  也可以在把每个 id 加入枢纽表时，加入其他字段的数据：  有时您可能想要使用一个命令，在建立新模型数据的同时附加关联。可以使用 save 方法达成目的：  上面的例子里，新的 role 模型对象会在储存的同时关联到 user 模型。也可以传入属性数组把数据加到关联数据库表：

D0959496关于string和byte之间的转换在网络编程中，socket发送数据是以byte字节数组发送的，所以要把其他类型的数据转化成byte[]类型//string 转成 bytestring s = hello!!;byte[] b = new byte[1024*1024];b = system.text.encoding.ascii.getbytes(s);//当string含有中文字符时用system.text.encoding.utf8.getbytes(s);sock.send(b);//byte 转成 stringbyte[] b1 = new byte[1024*1024*2];sock.receive(b1);string s1= system.text.encoding.ascii.getstring(b1);// system.text.encoding.utf8.getstring(b1);注意：在把byte数组转换成string的时候，由于byte数组有2m的字节，所以转换后得到的字符串s1也会填充到2m的字符（用\0来填充）所以，为了避免这个问题，可以使用receive返回的字节数来确定接收到byte的长度int length = sock.receive(b1);string s1 = system.text.encoding.ascii.getstring(b1, 0, length);//这样，s1就为byte实际的

D09133381.简介和基本术语1.机器学习主要用来提高某一方面的表现或者预测的精准性2.适用于：（1）没有或很难具体定义的问题；（2）具有内在模式，但是这种模式我们并不知道或者很难用编程实现的问题；（3）十分频繁的计算和决策；（4）针对个人，个性化的问题。3.机器学习可以用在生活的各个方面4.机器学习的流程和一些定义5.机器学习与数据挖掘6.机器学习与人工智能7.机器学习和统计

D0112898[015] Android平台的专业术语apk fileandroid application package file. each android application is compiled and packaged in a single file that includes all of the application's code (.dex files), resources, assets, and manifest file. the application package file can have any name but must use the .apk extension. for example: myexampleappname.apk. for convenience, an application package file is often referred to as an .apk.大意：扩展名为apk的文件是android应用程序包，每一个android应用程序包含的所有代码、资源和清单文件都被编译并打包成一个文件，这个文件的名字可任意取，但扩展名必须是.apk。例如，可以取名为myexampleappname.apk。为了方便起见，一个android应用程序包文件经常被称之为一个apk。.dex filecompiled android application code file.android programs are compiled into .dex (dalvik executable) files, which are in turn zipped into a single .apk file on the device. .dex files can be created by automatically translating compiled applications written in the java programming language.大意：android应用程序代码最终将会被编译成一个扩展名为dex((dalvik executable))的文件，我们所编写的java文件会自动地被编译成dex文件。actiona description of something that an intent sender wants done. an action is a string value assigned to an intent. action strings can be defined by android or by a third-party developer. for example, android.intent.action.view for a web url, or com.example.rumbler.shake_phone for a custom application to vibrate the phone.大意：action是对intent发送者所发送的intent（意图）的一种描述。action是被分配给intent的一个字符串。action可以由android系统定义，也可以由第三方开发人员定义。例如，对于一个网页url使用android.intent.action.view，或者在一个定制应用中使用com.example.rumbler.shake_phone使手机震动。activitya single screen in an application, with supporting java code, derived from the activity class. most commonly, an activity is visibly represented by a full screen window that can receive and handle ui events and perform complex tasks, because of the window it uses to render its window. though an activity is typically full screen, it can also be floating or transparent.大意：activity在应用程序里表现为一个“屏幕”，或应用程序的其中一个界面。通常，activity是可见的、全屏的窗口，它可以处理ui事件、执行复杂的任务。虽然activity通常是全屏的，但也可以设置使其浮动或透明。adbandroid debug bridge, a command-line debugging application included with the sdk. it provides tools to browse the device, copy tools on the device, and forward ports for debugging. if you are developing in eclipse using the adt plugin, adb is integrated into your development environment.大意：adb是android debug bridge的简写，即android调试桥，它是android sdk中自带的一个命令行调试应用程序。它所提供设备浏览工具、设备上的拷贝工具和为调试转寄端口的功能。如果你是在eclipse下使用adt插件进行开发，adb已经集成到你的开发环境中了。applicationfrom a component perspective, an android application consists of one or more activities, services, listeners, and intent receivers. from a source file perspective, an android application consists of code, resources, assets, and a single manifest. during compilation, these files are packaged in a single file called an application package file (.apk).大意：从组件的角度来看，android应用程序是由一个或多个activity、service、listener和intent receiver组成；从资源文件的角度来看，android应用程序是由java代码、xml资源文件、多媒体资源(音频、视频、其它文件等)和一个文件清单组成。在编译过程中，这些文件被打包成一个单一的叫做应用软件包的文件中(.apk)。content providera data-abstraction layer that you can use to safely expose your application's data to other applications. a content provider is built on the contentprovider class, which handles content query strings of a specific format to return data in a specific format.大意：content provider是一个数据抽象层，通过它你可以安全地将你应用程序中的数据暴露给其它的应用程序。content provider构建在contentprovider类之上，它负责处理指定式的查询串，并以指定的式返回数据。dalvikthe android platform's virtual machine. the dalvik vm is an interpreter-only virtual machine that executes files in the dalvik executable (.dex) format, a format that is optimized for efficient storage and memory-mappable execution. the virtual machine is register-based, and it can run classes compiled by a java language compiler that have been transformed into its native format using the included dx tool. the vm runs on top of posix-compliant operating systems, which it relies on for underlying functionality (such as threading and low level memory management). the dalvik core class library is intended to provide a familiar development base for those used to programming with java standard edition, but it is geared specifically to the needs of a small mobile device.大意：dalvik是android平台的虚拟机。dalvik是一个只能解释执行dex文件的虚拟机，dex文件针对存储性能和内存管理进行了优化。dalvik是基于寄存器的虚拟机，并且能够运行经过dalvik自带的“dx”工具转换过的java类。虚拟机运行在兼容posix的操作系统上，依赖于底层的功能(如线程和低级内存管理)。dalvik的核心类库有意做得与java标准版非常类，但它明显更适合小型移动设备。ddmsdalvik debug monitor service, a gui debugging application included with the sdk. it provides screen capture, log dump, and process examination capabilities. if you are developing in eclipse using the adt plugin, ddms is integrated into your development environment.大意：ddms即dalvik debug monitor service，它是sdk自带的一个图形化的调试工具，它提供了屏幕捕捉、日志存储和进程检测的能力。如果你在eclipse中使用adt插件进行开发，那么ddms已经被集成在你的开发环境中了。dialoga floating window that that acts as a lightweight form. a dialog can have button controls only and is intended to perform a simple action (such as button choice) and perhaps return a value. a dialog is not intended to persist in the history stack, contain complex layout, or perform complex actions. android provides a default simple dialog for you with optional buttons, though you can define your own dialog layout. the base class for dialogs is dialog.大意：dialog通常以一种轻量级的浮动窗口形式呈现，一个dialog可以只包含一个用于执行简单动作的按钮（如按钮选择）。dialog并不会被持久存储在历史栈中。所有对话框类的基类是dialog。drawablea compiled visual resource that can be used as a background, title, or other part of the screen. a drawable is typically loaded into another ui element, for example as a background image. a drawable is not able to receive events, but does assign various other properties such as state and scheduling, to enable subclasses such as animation objects or image libraries. many drawable objects are loaded from drawable resource files — xml or bitmap files that describe the image. drawable resources are compiled into subclasses of android.graphics.drawable.大意：drawable是经过编译的可视化资源，可以用于背景、标题或屏幕的其他部分。典型的情况，drawable被装载到另外一个ui元素中，例如将drawable作为背景图片。drawable不能够接收事件，但可以分配不同的其它属性，如“状态”。许多drawable对象是从描述图片的xml资源文件或位图文件中加载得到的。drawable资源被编译到android.graphics.drawable的一个子类中。intentan message object that you can use to launch or communicate with other applications/activities asynchronously. an intent object is an instance of intent. it includes several criteria fields that you can supply, to determine what application/activity receives the intent and what the receiver does when handling the intent. available criteria include include the desired action, a category, a data string, the mime type of the data, a handling class, and others. an application sends an intent to the android system, rather than sending it directly to another application/activity. the application can send the intent to a single target application or it can send it as a broadcast, which can in turn be handled by multiple applications sequentially. the android system is responsible for resolving the best-available receiver for each intent, based on the criteria supplied in the intent and the intent filters defined by other applications.大意：intent是一个消息对象，你可能通过intent启动其它应用程序或其它activity，或者通过intent与其它应用程序或activity进行异步交流。intent对象是intent的一个实例，它包含了许多方面：您能提供什么、确定应用程序或activity收到的意图以及处理intent时接受者做什么处理。intent包括：预期执行的动作(action)、动作类别(category)、数据(data)、数据类型(mime type)、处理类等。一个应用程序发送一个意图给android系统，而不是直接给发送给其它应用程序或activity。应用程序能够将意图发送给目标应用程序或者将意图作为一条广播发送，该广播能够被许多应用程序轮流处理。根据其它应用程序定义的意图过滤器，android系统负责解决：对于每一个意图，哪一个意图接收器最适合。intent filtera filter object that an application declares in its manifest file, to tell the system what types of intents each of its components is willing to accept and with what criteria. through an intent filter, an application can express interest in specific data types, intent actions, uri formats, and so on. when resolving an intent, the system evaluates all of the available intent filters in all applications and passes the intent to the application/activity that best matches the intent and criteria.大意：应用程序的intent filter(意图过滤器)声明在manifest文件中，它用于告诉系统应用程序的组件愿意接收哪种类型的意图。通过intent filter，应用程序能够表达出对哪些指定的数据类型、意图的行为、uri式等感兴趣。当要解决某个意图，系统会对所有应用程序的全部意图过滤器进行评估，然后将意图传递给最匹配的应用程序的activity。broadcast receiveran application class that listens for intents that are broadcast, rather than being sent to a single target application/activity. the system delivers a broadcast intent to all interested broadcast receivers, which handle the intent sequentially.大意：broadcast receiver是一个用于接收应用程序广播（不是发送给应用程序的activity）的类。系统将广播发送给所有对此广播感兴趣的广播接收器，这些广播接口器会按顺序处理该意图。layout resourcean xml file that describes the layout of an activity screen.大意：布局资源是一个用于描述屏幕布局的xml文件。manifest filean xml file that each application must define, to describe the application's package name, version, components (activities, intent filters, services), imported libraries, and describes the various activities, and so on.大意：清单文件是每一个应用程序都必须定义的xml文件，它用于描述应用程序的包名、版本、组件（activity、intent filters、services等）、引用的类库等。nine-patch / 9-patch / ninepatch imagea resizeable bitmap resource that can be used for backgrounds or other images on the device.大意：*.9.png是一种尺寸可变的位置资源，它可以用于背景图片或在设备上显示的图片。opengl esandroid provides opengl es libraries that you can use for fast, complex 3d images. it is harder to use than a canvas object, but better for 3d objects. the android.opengl and javax.microedition.khronos.opengles packages expose opengl es functionality.大意：你可以使用android提供了opengl es类库处理快速、复杂的3d图像。它比canvas对象的使用要难一些，但更适合3d应用。android.opengl和javax.microedition.khronos.opengles两个包暴露了opengl es的功能。resourcesnonprogrammatic application components that are external to the compiled application code, but which can be loaded from application code using a well-known reference format. android supports a variety of resource types, but a typical application's resources would consist of ui strings, ui layout components, graphics or other media files, and so on. an application uses resources to efficiently support localization and varied device profiles and states. for example, an application would include a separate set of resources for each supported local or device type, and it could include layout resources that are specific to the current screen orientation (landscape or portrait). for more information about resources, see resources and assets. the resources of an application are always stored in the res/* subfolders of the project.大意：资源可以理解为应用程序的“非编程”组件，即并不是通过编写代码产生的。但应用程序代码可以使用特定的引用式来使用资源。android系统支持大量的资源类型，最为典型的应用程序资源主要由ui字符串、ui布局组件、图像及其它媒体文件等组成。android应用程序使用资源来有效地支撑本地化和各种各样的设备，对于不同的手机屏幕大小、屏幕方向（横竖屏）都可以设置相应的资源。servicean object of class service that runs in the background (without any ui presence) to perform various persistent actions, such as playing music or monitoring network activity.大意：service运行在后台（无需任何ui界面）以开展许多持久的活动，例如：播放音乐或者监测网络的活动。themea set of properties (text size, background color, and so on) bundled together to define various default display settings. android provides a few standard themes, listed in r.style (starting with theme_).大意：theme是一系列定义多种默认显示设置的参数(文字大小、背景颜色等)。android系统在r.style中提供了一些标准的主题(以theme_开头)。uris in androidandroid uses uri strings as the basis for requesting data in a content provider (such as to retrieve a list of contacts) and for requesting actions in an intent (such as opening a web page in a browser). the uri scheme and format is specialized according to the type of use, and an application can handle specific uri schemes and strings in any way it wants. some uri schemes are reserved by system components. for example, requests for data from a content provider must use the content://. in an intent, a uri using an http:// scheme will be handled by the browser.大意：android使用uri字符串作为基本的数据请求(例如检索联系人列表)和动作请求(例如在浏览器中打开一个页面)的方式。uri字符串可以具有不同的式，但所有请求数据的uri都必须以“content://”开头。有效的动作uri字符串会被设备上的适当的程序处理，例如，以“http://”开头的uri字符串会被浏览器处理。viewan object that draws to a rectangular area on the screen and handles click, keystroke, and other interaction events. a view is a base class for most layout components of an activity or dialog screen (text boxes, windows, and so on). it receives calls from its parent object (see viewgroup, below)to draw itself, and informs its parent object about where and how big it would like to be (which may or may not be respected by the parent).大意：view是绘制在手机屏幕上的一块矩形区域，它能够处理点击事件、键盘事件和其它交互事件。view是大多数组件的基类，如文本框、对话框等。viewgroupa container object that groups a set of child views. the viewgroup is responsible for deciding where child views are positioned and how large they can be, as well as for calling each to draw itself when appropriate. some viewgroups are invisible and are for layout only, while others have an intrinsic ui (for instance, a scrolling list box). viewgroups are all in the widget package, but extend viewgroup.大意：viewgroup是包含一系列view的容器对象。viewgroup负责决定它里面包含的view显示在什么位置、占用的大小，以及在适当的时候调用每个view的方法来绘制它们自己。有些viewgroup是不可见的，它们仅仅用于布局，但有些viewgroup又有固定的ui，例如滚动的列表框组件。所有的viewgroup都继承了viewgroup类，并且位于android.widget包下。widgetone of a set of fully implemented view subclasses that render form elements and other ui components, such as a text box or popup menu. because a widget is fully implemented, it handles measuring and drawing itself and responding to screen events. widgets are all in the android.widget package.大意：widget即组件，它是一系列view子类（ui组件、布局等）的集合，例如文本框或弹出菜单。widget要负责测量和绘制它本身，并且还要对屏幕事件做出反应。所有的widget都位于android.widget包下。windowin an android application, an object derived from the abstract class window that specifies the elements of a generic window, such as the look and feel (title bar text, location and content of menus, and so on). dialog and activity use an implementation of this class to render a window. you do not need to implement this class or use windows in your application.大意：在android应用程序中，我们并不会实现或直接使用window这个类，它是一个抽象类。我们通常都是使用实现了window类的dialog和activity类生成一个窗口(window)。

D0432442java 使用Xfire 与 Axis 访问 webservices 的区别由于项目遇到问题,现将工作经验总结如下:java 关于 xfire 与 axis 调用 webservices 的区别首先 先看 两者之间的调用结构xfire 调用如下 :client client;client = new client(new url(serversetup.jgaddr));//地址object[] invoke = client.invoke(serversetup.writemethod, param);//方法,参数string res = invoke[0].tostring();//返回  axis 调用如下:   service service=new service();call call= (call) service.createcall();call.settargetendpointaddress(serversetup.jgaddr);//地址call.setoperation(serversetup.writemethod);//方法string res = (string) call.invoke(param); //参数   现将问题描述如下:  例如 webservices 访问地址为 :  有一个 queryobjectout 方法如下所示:  注意:当 nameapace 端口和webservices 地址端口一致时(注意红框区域) ,两种方法都可以使用. 当端口不一致时,xfrie就会提示webservices 404异常信息 这个时候使用axis 调用显示还是正常 经过仔细查阅webservices 结构发现 以下信息,注意红框区域:说明 webservices 是以 axis 开发提供服务的造成该问题的原因可能是2中组件之间数据解析方式可能有一定区别(当前还没有研究明白,谁明白可以留言给我)解决方式如下: 仔细阅读 webservices 结构使用框架,最好是使用对应框架 现将网络对比资料整理如下:1. axis2是apache下的一个重量级webservice框架，准确说它是一个web services / soap / wsdl 的引擎，是webservice框架的集大成者，它能不但能制作和发布webservice，而且可以生成java和其他语言版webservice客户端和服务端代码。这是它的优势所在。但是，这也不可避免的导致了axis2的复杂性，使用过的开发者都知道，它所依赖的包数量和大小都是很惊人的，打包部署发布都比较麻烦，不能很好的与现有应用整合为一体。但是如果你要开发java之外别的语言客户端，axis2提供的丰富工具将是你不二的选择。2、xfire是一个高性能的webservice框架，在java6之前，它的知名度甚至超过了apache的axis2，xfire的优点是开发方便，与现有的web整合很好，可以融为一体，并且开发也很方便。但是对java之外的语言，没有提供相关的代码工具。xfire后来被apache收购了，原因是它太优秀了，收购后，随着java6 jws的兴起，开源的webservice引擎已经不再被看好，渐渐的都败落了。3、如果应用程序需要多语言的支持，axis2 应当是首选了；4、如果应用程序是使用spring，xfire是一种更好的选择，特别对嵌入式的 webservices 来说；5、如果应用程序没有新的特性需要的话，就仍是用原来项目所用的框架，

D0397906Java基础之反射反射（主要用到的类class、package、field、constructor、method、array）  *对象有编译类型和运行类型。    object obj=new date(); //编译类型object,运行类型为date类型    date date=(date)obj;//必须得进行强制转化才能调用date类型的方法。  *反射就是得到某个类中所有成员的一种方式。  *class类描述所有的类，class的实例描述的就是类（也指的是jvm中的一份字节码）。  *class：用于描述一切类、接口。     class clz=date.class;//clz表示的是date的字节码     class clz1=string.class;//clz1表示的是string的字节码     //区分是那种类型的字节码（用泛型表示）     classdate clz=date.class;     classstring clz1=string.class;  *创建class对象（获取class实例,返回的是全限定类名（包类名））    //方法1    myobject obj=new myobject();    class c1=obj.getclass(); //获取myobject类的字节码，默认使用了泛型    //方法2    class? c2=class.forname(java.lang.string);//字符串必须是全类名（包类名）,?表示不知道返回类型。    //方法3    class c3=string.class; //类名.class(获取一份字节码)    *同一份字节码在jvm中有且只有一份（一个类在虚拟机中只有一份字节码）。  *常用方法    getpackage() //获取class对象所对应实体所在包的信息描述类的一个对象。返回package对象    getmodifilers();//返回class对象所对应实体用整数表示的类修饰符。    getname();//获取class对象所对应实体的完全限定名。    getsuperclass();//获取class对象所对应的实体的直接父类的class对象。    getinterfaces();//获取class对象所对应的实体实现的所有接口的class对象数组。    getfields();//获取class对象所对应实体的所有public字段。    getdeclaredfields();//获取所有字段    getconstructors();//获取class对象所对应实体的所有public的构造方法。    getdeclaredconstrucotrs();//获取所有构造方法。    getmathods();//获取class对象所对应的实体的所有public方法。    getdeclaredmethods();//获取所有方法  *java默认实现的9大内置class对象（八大基本数据类型和void关键字）    byte short int long float double char boolean void(关键字)    *对应class对象      byte.class  int.class  char.class  void.class ....     *八大基本数据类型多所对应的包装类中都有一个常量:type    type表示的是该包装类所对应的基本数据类型的class实例     system.out.println(integer.type==int.class);//返回true  *通过构造器创建对象     //方法1（带参数构造器只能使用此方式）       class clz=user.class;  //找到类字节码       constructoruser c=clz.getconstructor();//找到被调用的指定构造器       user user=c.newinstance(); //执行该构造器       //传递参数       class clz=user.class;         constructoruser c=clz.getconstructor(string.class);       user user=c.newinstance(fanqifu);      //用反射的好处         可以在只知道全限定名的情况下可以创建对象           class.forname(全限定名);     //方法2       //直接使用class对象的newinstance()方法（公共(public)的无参数构造器创建对象）。       class clz=user.class;       user user=clz.newinstance();//相当于new创建对象     //方法3 :调用私有的构造器创建对象需要忽略掉安全检查       class clz=user.class;         constructoruser c=clz.getdeclaredconstructor(string.class,int.class);       c.setaccessible(true);//忽略安全检查（私有类型的安全检查）       user user=c.newinstance(laofan,21);       *安全访问类        类accessibleobject 子类constractor、field、method（表示可以设置构造器，成员变量和成员方法的安全访问属性）。         使用setaccessible(true)方法设置是否可以访问,true表示可访问。

D0502371ECharts与Highcharts图表比较用过highchars图表组件的朋友应该都知道其可配置性强，但是图表与用户的交互性还是有所欠缺。今天我们就来聊聊一款既配置性强有与用户有着良好交互性的图表echarts吧！业界有无数js图表库，不乏优秀的代表，如chartjs，fusioncharts，amcharts，flot，rgraph，jqplot，grapha?l等等。有的是免费甚至开源的，有的则是商业的，百度一下就能找到他们。无法跟他们一一对比，在这选择了知名度很高的，一个优秀，成熟的商业图表库。先看看echarts和highcharts都支持哪些图表类型？图表类型echartshighcharts柱状图（条形图）支持支持折线图（面积图）支持支持饼图（环形图）支持支持散点图（气泡图）支持支持雷达图支持支持k线图支持highstock支持力导布局图支持不支持和弦图支持不支持地图支持支持力度不够 交互性太差特色图表（如仪表盘）不支持支持拖拽重计算支持不支持数据视图支持不支持图片导出支持支持动态类型切换支持支持（需要自己编写插件但是pie图切换麻烦）值域漫游支持不支持大规模散点支持不支持数据区域缩放支持支持图例开关支持支持多维度堆积支持支持混搭支持支持是否免费以及收费mit free3.0一下非商业免费 价格在90美元~3600美元基于上面的一个关于echarts和highcharts两大图表的对比表格，我想大家都对其各自的优势以及趋向性有所了解，其实细细研究和琢磨两者的区别还是有很多地方的。虽然都是基于html的canvas画布进行开发，但是echarts图表毕竟是基于mvc结构的图形开发包zrender的基础上进行的，所以各方面还是考虑比较成熟的。

D0144330Redis操作命令总结这篇文章主要介绍了redis操作命令总结,本文讲解了key pattern 查询相应的key、字符串类型的操作、链表操作、hashes类型及操作、集合结构操作、有序集合、服务器相关命令等内容,需要的朋友可以参考下一、key pattern 查询相应的key　　（1）redis允许模糊查询key　　有3个通配符 *、?、[]　　（2）randomkey：返回随机key　　　　（3）type key：返回key存储的类型　　（4）exists key：判断某个key是否存在　　（5）del key：删除key　　（6）rename key newkey：改名　　（7）renamenx key newkey：如果newkey不存在则修改成功　　（8）move key 1：将key移动到1数据库　　（9）ttl key：查询key的生命周期（秒）　　（10）expire key 整数：设置key的生命周期以秒为单位　　（11）pexpire key 整数：设置key的生命周期以毫秒为单位　　（12）pttl key：查询key 的生命周期（毫秒）　　（13）perisist key：把指定key设置为永久有效二、字符串类型的操作　　（1）set key value [ex 秒数] [px 毫秒数] [nx/xx]　　　　　　　　如果ex和px同时写，则以后面的有效期为准　　　　　　nx：如果key不存在则建立　　　　　　xx：如果key存在则修改其　　（2）get key：取　　（3）mset key1 value1 key2 value2 一次设置多个　　（4）mget key1 key2 ：一次获取多个　　（5）setrange key offset value：把字符串的offset偏移字节改成value　　　　　　　　　　　　　　　　　　如果偏移量  字符串长度，该字符自动补0x00　　（6）append key value ：把value追加到key 的原上　　（7）getrange key start stop：获取字符串中[start, stop]范围的　　　　　　　　　　　　　　　　　　对于字符串的下标，左数从0开始，右数从-1开始　　　　　　　　　　　　　　　　　　注意：当startlength，则返回空字符串　　　　　　　　　　　　　　　　　　　　　当stop=length，则截取至字符串尾　　　　　　　　　　　　　　　　　　　　　如果start所处位置在stop右边，则返回空字符串　　（8）getset key nrevalue：获取并返回旧，在设置新　　（9）incr key：自增，返回新，如果incr一个不是int的value则返回错误，incr一个不存在的key，则设置key为1　　（10）incrby key 2：跳2自增　　（11）incrbyfloat by 0.7： 自增浮点数　　　（12）setbit key offset value：设置offset对应二进制上的，返回该位上的旧　　　　　　　　　　　　　　　　　注意：如果offset过大，则会在中间填充0　　　　　　　　　　　　　　　　　　　　offset最大到多少　　　　　　　　　　　　　　　　　　　　　2^32-1，即可推出最大的字符串为512m　　（13）bitop operation destkey key1 [key2..] 对key1 key2做opecation并将结果保存在destkey上　　　　　　　　　　　　　　　　　　　　　　　　　　opecation可以是and or not xor　　（14）strlen key：取指定key的value的长度　 （15）setex key time value：设置key对应的value，并设置有效期为time秒三、链表操作　　redis的list类型其实就是一个每个子元素都是string类型的双向链表，链表的最大长度是2^32。list既可以用做栈，也可以用做队列。　　list的pop操作还有阻塞版本，主要是为了避免轮询　　（1）lpush key value：把插入到链表头部　　（2）rpush key value：把插入到链表尾部　　（3）lpop key ：返回并删除链表头部元素　　（4）rpop key： 返回并删除链表尾部元素　　（5）lrange key start stop：返回链表中[start, stop]中的元素　　（6）lrem key count value：从链表中删除value，删除count的绝对个value后结束　　　　　　　　　　　　　　　　count  0 从表头删除　　count  0 从表尾删除　　count=0 全部删除　　（7）ltrim key start stop：剪切key对应的链接，切[start, stop]一段并把改制重新赋给key　　（8）lindex key index：返回index索引上的　　（9）llen key：计算链表的元素个数　　（10）linsert key after|before search value：在key 链表中寻找search，并在search之前|之后插入value　　（11）rpoplpush source dest：把source 的末尾拿出，放到dest头部，并返回单元　　　　应用场景： task  bak 双链表完成安全队列　业务逻辑： rpoplpush task bak　　　　　　　　　接收返回并做业务处理　　　　　　　　　如果成功则rpop bak清除任务，如果不成功，下次从bak表取任务　　（12）brpop，blpop key timeout：等待弹出key的尾/头元素　　　　　　　　　　　　　　　　timeout为等待超时时间，如果timeout为0则一直等待下去　　　　　　应用场景：长轮询ajax，在线聊天时能用到四、hashes类型及操作　　redis hash 是一个string类型的field和value的映射表，它的添加、删除操作都是o(1)（平均）。hash特别适用于存储对象，将一个对象存储在hash类型中会占用更少的内存，并且可以方便的存取整个对象。　　配置： hash_max_zipmap_entries 64 #配置字段最多64个　　　　　 hash_max_zipmap_value 512 #配置value最大为512字节　　（1）hset myhash field value：设置myhash的field为value　　（2）hsetnx myhash field value：不存在的情况下设置myhash的field为value　　（3）hmset myhash field1 value1 field2 value2：同时设置多个field　　（4）hget myhash field：获取指定的hash field　　（5）hmget myhash field1 field2：一次获取多个field　　（6）hincrby myhash field 5：指定的hash field加上给定的　　（7）hexists myhash field：测试指定的field是否存在　　（8）hlen myhash：返回hash的field数量　　（9）hdel myhash field：删除指定的field　　（10）hkeys myhash：返回hash所有的field　　（11）hvals myhash：返回hash所有的value　　（12）hgetall myhash：获取某个hash中全部的field及value　五、集合结构操作　　特点：无序性、确定性、唯一性　　（1）sadd key value1 value2：往集合里面添加元素　　（2）smembers key：获取集合所有的元素　　（3）srem key value：删除集合某个元素　　（4）spop key：返回并删除集合中1个随机元素（可以坐抽奖，不会重复抽到某人）　　　　　（5）srandmember key：随机取一个元素　　（6）sismember key value：判断集合是否有某个　　（7）scard key：返回集合元素的个数　　（8）smove source dest value：把source的value移动到dest集合中　　（9）sinter key1 key2 key3：求key1 key2 key3的交集　　（10）sunion key1 key2：求key1 key2 的并集　　（11）sdiff key1 key2：求key1 key2的差集　　（12）sinterstore res key1 key2：求key1 key2的交集并存在res里　六、有序集合　　概念：它是在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动按新的调整顺序。可以理解为有两列的mysql表，一列存储value，一列存储顺序，操作中key理解为zset的名字。　　和set一样sorted，sets也是string类型元素的集合，不同的是每个元素都会关联一个double型的score。sorted set的实现是skip list和hash table的混合体。　　当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，所以给定一个元素获取score的开销是o(1)。另一个score到元素的映射被添加的skip list，并按照score排序，所以就可以有序地获取集合中的元素。添加、删除操作开销都是o(logn)和skip list的开销一致，redis的skip list 实现是双向链表，这样就可以逆序从尾部去元素。sorted set最经常使用方式应该就是作为索引来使用，我们可以把要排序的字段作为score存储，对象的id当元素存储。　　（1）zadd key score1 value1：添加元素　　（2）zrange key start stop [withscore]：把集合排序后,返回名次[start,stop]的元素 默认是升续排列 withscores 是把score也打印出来　　（3）zrank key member：查询member的排名（升序0名开始）　　（4）zrangebyscore key min max [withscores] limit offset n：集合（升序）排序后取score在[min, max]内的元素，并跳过offset个，取出n个　　（5）zrevrank key member：查询member排名（降序 0名开始）　　（6）zremrangebyscore key min max：按照score来删除元素，删除score在[min, max]之间　　（7）zrem key value1 value2：删除集合中的元素　　（8）zremrangebyrank key start end：按排名删除元素，删除名次在[start, end]之间的　　（9）zcard key：返回集合元素的个数　　（10）zcount key min max：返回[min, max]区间内元素数量　　（11）zinterstore dest numkeys key1[key2..] [weights weight1 [weight2...]] [aggregate sum|min|max]　　　　　　求key1，key2的交集，key1，key2的权分别是weight1，weight2　　　　　　聚合方法用 sum|min|max　　　　　　聚合结果 保存子dest集合内　　　　　　注意：weights,aggregate如何理解？　　　　　　　　　　答：如果有交集，交集元素又有score，score怎么处理？aggregate num-score相加，min最小score，max最大score，另外可以通过weights设置不同的key的权重，交集时 score*weight七、服务器相关命令　　（1）ping：测定连接是否存活　　（2）echo：在命令行打印一些内容　　（3）select：选择数据库　　（4）quit：退出连接　　（5）dbsize：返回当前数据库中key的数目　　（6）info：获取服务器的信息和统计　　（7）monitor：实时转储收到的请求　　（8）config get 配置项：获取服务器配置的信息　　　　 config set 配置项 ：设置配置项信息　　（9）flushdb：删除当前选择数据库中所有的key　　（10）flushall：删除所有数据库中的所有的key　　（11）time：显示服务器时间，时间戳（秒），微秒数　　（12）bgrewriteaof：后台保存rdb快照　　（13）bgsave：后台保存rdb快照　　（14）save：保存rdb快照　　（15）lastsave：上次保存时间　　（16）shutdown [save/nosave]　　　　　　注意：如果不小心运行了flushall，立即shutdown nosave，关闭服务器，然后手工编辑aof文件，去掉文件中的flushall相关行，然后开启服务器，就可以倒回原来是数据。如果flushall之后，系统恰好bgwriteaof了，那么aof就清空了，数据丢失。　　（17）showlog：显示慢查询　　　　　　问：多慢才叫慢？　　　　　　答：由slowlog-log-slower-than 10000，来指定（单位为微秒）　　　　　　问：服务器存储多少条慢查询记录　　　　　　答：由slowlog-max-len 128，来做限制

D0343258利用vbs 运行程序 并使窗口隐藏利用vbs运行程序并使窗口隐藏首先了解下wshshell对象windows脚本宿主提供了一种便捷的方式，可以用于获取系统环境变量的访问、创建快捷方式、访问windows的特殊文件夹，如windowsdesktop，以及添加或删除注册表条目。还可以使用shell对象的功能创建更多的定制对话框以进行用户交互。wshshell对象有三个属性：●currentdirectory●environment●specialfolderscurrentdirectory该属性获取或更改当前活动目录就是你当前运行脚本的目录environment该属性返回wshenvironment对象(一个环境变量集合)。specialfolders该属性返回一个specialfolders对象(一个特殊文件夹集合)。wshshell对象的方法11个●appactivate用于激活一个指定的已经打开的应用程序窗口。●createshortcut创建一个新的快捷方式，或打开一个已有的快捷方式。●expandenvironmentstrings返回环境变量的扩充。●logevent向日志文件中添加一个事件条目。●popup在弹出式消息框中显示文本。●regdelete删除注册表●regread读取注册表●regwrite写入注册表●run在一个新进程中运行一个程序●sendkeys活跃窗口发送一次或多次击键●exec在一个子命令解释器中运行一个应用程序，子命令解释器提供对stdin、stdout和stderr流的访问下面通过几个例子来实践演示下dimwsh,motionpath,desktoppath'定义变量setwsh=createobject(wscript.shell)'创建一个wscript.shell对象的实例'currentdirectory属性的使用motionpath=wsh.currentdirectory'获得当前运行的目录并把赋给变量motionpathmsgboxmotionpath'environment属性的使用setwshenv=wsh.environment(system)'创建一个environment对象msgboxwshenv(os)'specialfolders属性的使用desktoppath=wsh.specialfolders(desktop)msgboxdesktoppath'appactivate方法的使用激活计算器wsh.appactivatecalc'createshortcut方法的使用创建一个快捷方式setcmdlnk=wsh.createshortcut(desktoppath\mycmd.lnk)cmdlnk.targetpath=c:\windows\system32\cmd.execmdlnk.windowstyle=3cmdlnk.save'run方法的使用wsh.runcmd,1------------------------------------------------分割线-----------------------------------------如何使程序运行并隐藏窗口呢那就要使用run方法run方法就详解..object.run(strcommand,[intwindowstyle],[bwaitonreturn])object：wshshell对象。strcommand：一个字符串，表示想要运行的命令行，必须包含所有要传递给可执行文件的参数。intwindowstyle：可选。一个整数，表示程序窗口的外观。bwaitonreturn：可选。一个boolean，表示脚本在其下一条语句之前是否需要等待程序结束。windowstyle0隐藏当前窗口并激活另一个窗口1激活并显示一个窗口如果该窗口处于最小化或最大化状态，系统将恢复其原始尺寸如果是初次显示该窗口，应用程序就应该指定这个标志2激活并以最小化状态显示窗口3激活并以最大化状态显示窗口4以其最近位置和尺寸显示一个窗口活跃的窗口将继续保持活跃5以其当前位置和尺寸显示一个窗口6最小化指定的窗口并将其激活为z序列中仅次于顶层的窗口7以最小化形式显示窗口活跃的窗口将继续保持活跃8以其当前状态显示窗口活跃的窗口将继续保持活跃9激活并显示窗口如果该窗口处于最小化或最大化状态，系统将恢复其原始尺寸根据参数可以知道只要把windowstyle赋为0即可隐藏窗口dimwshsetwsh=createobject(wscript.shell)'创建一个wscript.shell对象的实例wsh.runcmd,0‘运行cmd并隐藏窗口原文：

D0434434Libevent0.1学习之queue.h  最近打算研究一下网络库，发现用了freebsd的中的尾队列来存储各种事件队列。下面就是一些学习的一些笔记。中定义了一系列的宏操作去实现单链表、双链表、简单队列、尾队列和循环链表(的内容见文章结尾)。他们的特点对比如下： 单链表： ：一个指向第一个元素的指针 ：一个指向下一个元素的指针 ：o(n) ：头部、元素后面双链表： ：一个指向第一个元素的指针 ：一个指向下一个元素的指针，和一个指向前一个元素的le_next的地址的指针 ：o(1) ：头部、元素前面、元素后面简单队列 ：一个指向第一个元素的指针和一个指向最后一个元素的sqe_next地址的指针 ：一个指向下一个元素的指针 ：o(n) ：头部、尾部、元素后面尾队列 ：一个指向第一个元素的指针和一个指向最后一个元素的tqe_next地址的指针 ：一个指向下一个元素的指针和一个指向前一个元素的tqe_next地址的指针 ：o(1) ：头部、尾部、元素后面、元素前面循环队列 ：一个指向第一个元素的指针和一个指向最后一个元素的指针 ：一个指向下一个元素的指针和一个指向前一个元素的指针 ：o(1) ：头部、尾部、元素后面、元素前面其中尾队列和双链表的元素定义都包含了一个指针，它指向前一个元素的变量的地址，也就是二级指针，这么设计我想是因为： 他们都有一个头部，这个头部都包含有一个指向第一个元素的指针。所以当在他们头部插入一个元素时（执行宏），使用这种二级指针可以很方便的插入。libevent中尾队列的使用libevent中使用了尾队列来存储各种事件。event结构体定义可以看出中包含4种事件队列，变量中的指向下一个，这样就形成了一个队列。各种事件队列的头部定义上面定义了4种事件队列头，定时器事件队列，写事件队列，读事件队列，待添加事件队列。待添加事件队列中的事件为需要延时加入的事件。queue.h内容

D0134719maven如何修改本地仓库与中央仓库摘要运行maven的时候，maven所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。目录[-]什么是maven仓库在不用maven的时候，比如说以前我们用ant构建项目，在项目目录下，往往会看到一个名为/lib的子目录，那里存放着各类第三方依赖jar文件，如log4j.jar，junit.jar等等。每建立一个项目，你都需要建立这样的一个/lib目录，然后复制一对jar文件，这是很明显的重复。重复永远是噩梦的起点，多个项目不共用相同的jar文件，不仅会造成磁盘资源的浪费，也使得版本的一致性管理变得困难。此外，如果你使用版本管理工具，如svn（你没有使用版本管理工具？马上试试svn吧，它能帮你解决很多头疼的问题），你需要将大量的jar文件提交到代码库里，可是版本管理工具在处理二进制文件方面并不出色。maven仓库就是放置所有jar文件（war，zip，pom等等）的地方，所有maven项目可以从同一个maven仓库中获取自己所需要的依赖jar，这节省了磁盘资源。此外，由于maven仓库中所有的jar都有其自己的坐标，该坐标告诉maven它的组id，构件id，版本，打包方式等等，因此maven项目可以方便的进行依赖版本管理。你也不在需要提交jar文件到scm仓库中，你可以建立一个组织层次的maven仓库，供所有成员使用。简言之，maven仓库能帮助我们管理构件（主要是jar）。本地仓库 vs. 远程仓库运行maven的时候，maven所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。比如说，你的项目配置了junit-3.8的依赖，在你运行mvn test的时候，maven需要使用junit-3.8的jar文件，它首先根据坐标查找本地仓库，如果找到，就直接使用。如果没有，maven会检查可用的远程仓库配置，然后逐个尝试这些远程仓库去下载junit-3.8的jar文件，如果远程仓库存在该文件，maven会将其下载到本地仓库中，继而使用。如果尝试过所有远程仓库之后，maven还是没能够下载到该文件，它就会报错。maven缺省的本地仓库地址为${user.home}/.m2/repository。也就是说，一个用户会对应的拥有一个本地仓库。你也可以自定义本地仓库的位置，修改${user.home}/.m2/settings.xml：xml代码12345你还可以在运行时指定本地仓库位置：mvn clean install -dmaven.repo.local=/home/juven/myrepo/还有一点需要理解的是，当我们运行install的时候，maven实际上是将项目生成的构件安装到了本地仓库，也就是说，只有install了之后，其它项目才能使用此项目生成的构件。了解了本地仓库，接着了解一下maven缺省的远程仓库，即maven中央仓库。安装好maven之后，我们可以建立一个简单的项目，配置一些简单的依赖，然后运行mvn clean install，项目就构建好了。我们没有手工的去下载任何jar文件，这一切都是因为maven中央仓库的存在，当maven在本地仓库找不到需要的jar文件时，它会查找远程仓库，而一个原始的maven安装就自带了一个远程仓库——maven中央仓库。这个maven中央仓库是在哪里定义的呢？在我的机器上，我安装了maven-2.0.10，我可以找到这个文件：${m2_home}/lib/maven-2.0.10-uber.jar，打开该文件，能找到超级pom：\org\apache\maven\project\pom-4.0.0.xml，它是所有maven pom的父pom，所有maven项目继承该配置，你可以在这个pom中发现如下配置：xml代码1234567891011关于远程仓库的配置，下面的小节我会详细解释，这里我们只要知道，中央仓库的id为central，远程url地址为，它关闭了snapshot版本构件下载的支持。在pom中配置远程仓库前面我们看到超级pom配置了id为central的远程仓库，我们可以在pom中配置其它的远程仓库。这样做的原因有很多，比如你有一个局域网的远程仓库，使用该仓库能大大提高下载速度，继而提高构建速度，也有可能你依赖的一个jar在central中找不到，它只存在于某个特定的公共仓库，这样你也不得不添加那个远程仓库的配置。这里我配置一个远程仓库指向中央仓库的中国镜像：xml代码123456789101112131415161718192021222324252627282930关于repositories的更详细的配置及相关解释，请参考：。至于pluginrepositories，这是配置maven从什么地方下载插件构件（maven的所有实际行为都由其插件完成）。该元素的内部配置和repository完全一样，不再解释。在settings.xml中配置远程仓库我们知道了如何在pom中配置远程仓库，但考虑这样的情况：在一个公司内部，同时进行这3个项目，而且以后随着这几个项目的结束，越来越多的项目会开始；同时，公司内部建立一个maven仓库。我们统一为所有这些项目配置该仓库，于是不得不为每个项目提供同样的配置。问题出现了，这是重复！其实我们可以做到只配置一次，在哪里配置呢？就是settings.xml。不过事情没有那么简单，不是简单的将pom中的repositories及pluginrepositories元素复制到settings.xml中就可以，setting.xml不直接支持这两个元素。但我们还是有一个并不复杂的解决方案，就是利用profile，如下：xml代码12345678910111213使用profile为settings.xml添加仓库提供了一种用户全局范围的仓库配置。镜像如果你的地理位置附近有一个速度更快的central镜像，或者你想覆盖central仓库配置，或者你想为所有pom使用唯一的一个远程仓库（这个远程仓库代理的所有必要的其它仓库），你可以使用settings.xml中的mirror配置。以下的mirror配置用maven.net.cn覆盖了maven自带的central：xml代码123456789101112xml代码123456789101112关于更加高级的镜像配置，可以参考：。分发构件至远程仓库mvn install会将项目生成的构件安装到本地maven仓库，mvn deploy用来将项目生成的构件分发到远程maven仓库。本地maven仓库的构件只能供当前用户使用，在分发到远程maven仓库之后，所有能访问该仓库的用户都能使用你的构件。我们需要配置pom的distributionmanagement来指定maven分发构件的位置，如下：xml代码12345678910111213141516一般来说，分发构件到远程仓库需要认证，如果你没有配置任何认证信息，你往往会得到401错误。这个时候，如下在settings.xml中配置认证信息：xml代码12345678910111213141516小结本文介绍了maven仓库，它是什么？本地仓库，远程仓库，中央仓库具体是指什么？并介绍了如何在pom中配置项目层次的仓库，在settings中配置用户层次的仓库，以及mirror。本文还介绍了如何安装构件到本地仓库，如何分发构件至仓库。
